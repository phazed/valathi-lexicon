<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Vrahune Generator Hub</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    :root {
      --bg: #050505;
      --bg-alt: #101010;
      --accent: #c0c0c0;
      --accent-soft: rgba(192,192,192,0.22);
      --text: #f5f5f5;
      --muted: #a0a0a0;
      --border: #2a2a2a;
      --danger: #ff8080;
      --shadow-soft: 0 14px 40px rgba(0, 0, 0, 0.75);
      --radius-lg: 16px;
    }

    * {
      box-sizing: border-box;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      margin: 0;
      padding: 0;
      background: radial-gradient(circle at top, #222 0, #050505 55%, #000 100%);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      align-items: stretch;
      justify-content: center;
    }

    .app-shell {
      max-width: 1200px;
      width: 100%;
      padding: 24px;
    }

    .card {
      background: linear-gradient(145deg, rgba(8, 8, 8, 0.97), rgba(4, 4, 4, 0.99));
      border-radius: var(--radius-lg);
      border: 1px solid var(--border);
      box-shadow: var(--shadow-soft);
      padding: 20px 20px 18px;
      backdrop-filter: blur(10px);
    }

    h1 {
      margin: 0 0 8px;
      font-weight: 600;
      letter-spacing: 0.02em;
      font-size: 1.4rem;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    h1 span.logo {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 26px;
      height: 26px;
      border-radius: 999px;
      border: 1px solid rgba(192,192,192,0.55);
      background: radial-gradient(circle at top, rgba(230,230,230,0.25), transparent 60%);
      font-size: 0.9rem;
      color: var(--text);
    }

    .subtitle {
      font-size: 0.85rem;
      color: var(--muted);
      margin-bottom: 6px;
    }

    label {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
      display: block;
      margin-bottom: 4px;
    }

    input[type="text"],
    input[type="number"],
    textarea,
    select {
      width: 100%;
      padding: 8px 9px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(12, 12, 12, 0.95);
      color: var(--text);
      font-size: 0.9rem;
      outline: none;
      transition: border-color 0.18s ease, box-shadow 0.18s ease, background 0.18s ease;
    }

    input[type="text"]:focus,
    input[type="number"]:focus,
    textarea:focus,
    select:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent-soft);
      background: rgba(18, 18, 18, 1);
    }

    textarea {
      resize: vertical;
      min-height: 120px;
    }

    button {
      border-radius: 999px;
      border: 1px solid transparent;
      padding: 7px 14px;
      font-size: 0.85rem;
      font-weight: 500;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: transform 0.12s ease, box-shadow 0.12s ease, background 0.12s ease, border-color 0.12s ease;
    }

    .btn-primary {
      background: linear-gradient(135deg, #f5f5f5, #bfbfbf);
      color: #111;
      box-shadow: 0 8px 22px rgba(200, 200, 200, 0.4);
    }

    .btn-primary:hover {
      transform: translateY(-1px);
      box-shadow: 0 12px 30px rgba(230, 230, 230, 0.6);
    }

    .btn-secondary {
      background: transparent;
      border-color: var(--border);
      color: var(--muted);
    }

    .btn-secondary:hover {
      border-color: var(--accent-soft);
      background: rgba(18, 18, 18, 0.96);
    }

    .btn-small {
      padding: 4px 10px;
      font-size: 0.8rem;
    }

    .btn-icon {
      width: 26px;
      height: 26px;
      border-radius: 8px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      font-size: 1rem;
      border-color: var(--border);
    }

    .btn-icon:hover {
      border-color: var(--accent);
      background: rgba(255, 255, 255, 0.04);
    }

    .row {
      display: flex;
      gap: 10px;
      align-items: flex-end;
      margin-bottom: 12px;
      flex-wrap: wrap;
    }

    .col {
      flex: 1;
      min-width: 140px;
    }

    .section-title {
      font-size: 0.95rem;
      margin-bottom: 6px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .section-title span {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .muted {
      color: var(--muted);
      font-size: 0.8rem;
    }

    hr {
      border: none;
      border-top: 1px solid var(--border);
      margin: 16px 0;
    }

    .danger {
      color: var(--danger);
    }

    .hub-body {
      display: flex;
      gap: 16px;
      margin-top: 8px;
    }

    .nav-column {
      width: 280px;
      min-width: 240px;
      max-width: 320px;
      display: flex;
      flex-direction: column;
    }

    .detail-column {
      flex: 1;
      min-width: 0;
      display: flex;
      flex-direction: column;
    }

    @media (max-width: 900px) {
      .hub-body {
        flex-direction: column;
      }
      .nav-column {
        width: 100%;
        max-width: 100%;
      }
    }

    .nav-area {
      border-radius: 12px;
      border: 1px solid rgba(60,60,60,0.9);
      background: linear-gradient(180deg, rgba(10,10,10,0.98), rgba(5,5,5,0.98));
      padding: 6px 8px;
      max-height: 360px;
      overflow-y: auto;
      margin-top: 8px;
      margin-bottom: 12px;
    }

    .nav-folder-heading {
      font-size: 0.78rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.11em;
      margin: 4px 2px 0;
      padding: 2px 4px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 4px;
    }

    .folder-toggle {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      cursor: pointer;
      flex: 1;
      min-width: 0;
    }

    .folder-arrow {
      font-size: 0.8rem;
      opacity: 0.9;
    }

    .folder-label {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .folder-badge {
      font-size: 0.72rem;
      opacity: 0.85;
      margin-left: 4px;
    }

    .folder-rename-btn {
      border-radius: 8px;
      padding: 2px 6px;
      font-size: 0.7rem;
      border-color: var(--border);
      background: transparent;
      color: var(--muted);
    }

    .folder-rename-btn:hover {
      border-color: var(--accent-soft);
      background: rgba(255,255,255,0.03);
      color: var(--text);
    }

    .nav-generator {
      font-size: 0.86rem;
      padding: 5px 8px;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: flex-start;
      gap: 6px;
      margin: 2px 2px;
      border: 1px solid transparent;
    }

    .nav-generator span.name {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .nav-generator:hover {
      border-color: var(--border);
      background: rgba(255,255,255,0.03);
    }

    .nav-generator.active {
      border-color: var(--accent);
      background: rgba(255,255,255,0.06);
    }

    .create-box {
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px dashed rgba(120,120,120,0.7);
      background: rgba(10,10,10,0.95);
    }

    .generator-panel {
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(70,70,70,0.9);
      background: radial-gradient(circle at top left, rgba(255,255,255,0.05), rgba(8,8,8,0.96));
      min-height: 80px;
      margin-top: 8px;
    }

    .generator-title-main {
      font-size: 1rem;
      font-weight: 600;
      margin-bottom: 4px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .generated-list {
      margin-top: 8px;
      padding: 6px 8px;
      border-radius: 10px;
      border: 1px solid rgba(45,45,45,0.9);
      background: rgba(8,8,8,0.98);
      max-height: 220px;
      overflow-y: auto;
      font-size: 0.88rem;
    }

    .generated-item {
      padding: 3px 0;
      cursor: pointer;
    }

    .generated-item:hover {
      text-decoration: underline;
    }

    .copy-message {
      margin-top: 6px;
      font-size: 0.78rem;
      color: var(--muted);
    }

    .items-expanded {
      min-height: 260px !important;
      max-height: 70vh;
    }

    table.token-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 4px;
      font-size: 0.8rem;
    }

    table.token-table th,
    table.token-table td {
      border-bottom: 1px solid var(--border);
      padding: 4px 4px;
      text-align: left;
    }

    table.token-table th {
      font-weight: 500;
      color: var(--muted);
    }
  </style>
</head>
<body>
  <div class="app-shell">
    <div class="card">
      <h1>
        <span class="logo">V</span>
        Vrahune Generator Hub
      </h1>
      <div class="subtitle">
        Left: folders & generators (collapsible, renameable). Right: generator controls & results.
      </div>

      <div class="section-title" style="justify-content:flex-end; margin-bottom:4px;">
        <span class="muted" style="font-size:0.78rem;">Database</span>
        <button id="downloadDbBtn" class="btn-secondary btn-small">
          Download database (JSON)
        </button>
      </div>

      <div class="hub-body">
        <!-- LEFT COLUMN -->
        <div class="nav-column">
          <div class="section-title">
            <span>Generators</span>
            <button id="addGeneratorBtn" class="btn-secondary btn-icon" title="Create new generator">
              ＋
            </button>
          </div>

          <div id="generatorCreateBox" class="create-box" style="display:none;">
            <div class="muted" style="margin-bottom:6px;">
              Create or edit a generator. Items can be names, lexicon entries, book titles, etc.
              One per line. Duplicates are removed automatically.
            </div>

            <div class="row">
              <div class="col">
                <label for="genFolderSelect">Folder</label>
                <select id="genFolderSelect"></select>
                <input id="genFolderNewInput" type="text" placeholder="New folder name" style="display:none; margin-top:4px;">
              </div>
              <div class="col">
                <label for="genNameInput">Generator name</label>
                <input id="genNameInput" type="text" placeholder="e.g. Valathi Lexicon, Tavern Names">
              </div>
              <div class="col">
                <label for="genTypeInput">Type</label>
                <select id="genTypeInput">
                  <option value="list">Random list</option>
                  <option value="lexicon">Lexicon translator</option>
                  <option value="advanced">Advanced</option>
                </select>
              </div>
            </div>

            <div class="row" id="genItemsRow">
              <div class="col">
                <label for="genItemsInput">Items list</label>
                <textarea id="genItemsInput" placeholder="For list: one item per line&#10;For lexicon: english = valathi"></textarea>
                <button type="button" id="expandItemsBtn" class="btn-secondary btn-small" style="margin-top:4px;">
                  Expand list editor
                </button>
              </div>
            </div>

            <div class="row">
              <button id="saveGeneratorBtn" class="btn-primary">
                Save generator
              </button>
              <button id="cancelGeneratorBtn" class="btn-secondary">
                Cancel
              </button>
            </div>

            <div id="generatorCreateMessage" class="muted"></div>
          </div>

          <div id="generatorNav" class="nav-area"></div>
        </div>

        <!-- RIGHT COLUMN -->
        <div class="detail-column">
          <div class="section-title">
            <span id="activeGeneratorLabel">No generator selected</span>
          </div>

          <div id="generatorPanel" class="generator-panel">
            <div class="muted">
              Choose a generator from the left, or click ＋ to create one.
            </div>
          </div>

          <div id="copyMessage" class="copy-message">
            Click any generated item or lexicon entry to copy.
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // --------------------------------
    // KEYS & STATE
    // --------------------------------
    const GEN_STORAGE_KEY = "vrahuneGeneratorsV4";
    const FOLDER_STATE_KEY = "vrahuneFolderStateV1";

    let activeGenerator = null;
    let editingGeneratorId = null;
    let itemsExpanded = false;
    let folderState = {}; // { folderName: { collapsed: bool } }

    // --------------------------------
    // INITIAL LEXICON SEED
    // --------------------------------
    const valathiLexiconSeed = [
      { english: "high, noble, elevated, bright", valathi: "val" },
      { english: "forest, wooded land", valathi: "’ath" },
      { english: "land, domain", valathi: "anna" },
      { english: "seat, city, foundation", valathi: "dor" },
      { english: "stone, mountain, cliff", valathi: "vor" },
      { english: "water, lake", valathi: "mir" },
      { english: "river, flowing path", valathi: "len" },
      { english: "wind, air current", valathi: "vrae" },
      { english: "star, light in the dark", valathi: "sel" },
      { english: "sea, great water", valathi: "thal" },
      { english: "north, cold lands", valathi: "nor" },
      { english: "dusk, evening star", valathi: "ves" },
      { english: "guardian, warden", valathi: "vel" },
      { english: "song, art, beautiful craft", valathi: "rin" },
      { english: "lore, deep knowledge", valathi: "ith" },
      { english: "peace, calm", valathi: "ser" },
      { english: "flame, passion, drive", valathi: "nar" },
      { english: "life, breath, vitality", valathi: "laen" },
      { english: "hidden, secret, veiled", valathi: "vyn" },
      { english: "world, the continent", valathi: "Vrahune" },
      { english: "noble-forest land (realm)", valathi: "Val’athanna" },
      { english: "high seat, noble city", valathi: "Valdora" }
    ];

    // --------------------------------
    // HELPERS
    // --------------------------------
    function rand(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }

    function showCopyMessage(text) {
      const msg = document.getElementById("copyMessage");
      msg.textContent = `Copied: "${text}"`;
      setTimeout(() => {
        msg.textContent = "Click any generated item or lexicon entry to copy.";
      }, 2500);
    }

    function handleCopyClick(event) {
      const target = event.target;
      if (!target.classList.contains("generated-item")) return;
      const text = target.textContent.trim();
      if (!text) return;
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(text)
          .then(() => showCopyMessage(text))
          .catch(() => showCopyMessage(text));
      } else {
        showCopyMessage(text);
      }
    }

    function parseGeneratorItems(rawText) {
      if (!rawText) return { items: [], duplicates: 0 };
      const lines = rawText.split(/\r?\n/);
      const set = new Set();
      const items = [];
      let total = 0;

      for (const line of lines) {
        const t = line.trim();
        if (!t) continue;
        total++;
        const key = t.toLowerCase();
        if (!set.has(key)) {
          set.add(key);
          items.push(t);
        }
      }
      const duplicates = Math.max(0, total - items.length);
      return { items, duplicates };
    }

    function parseLexiconText(rawText) {
      if (!rawText) return { items: [], duplicates: 0 };
      const lines = rawText.split(/\r?\n/);
      const map = new Map();
      let total = 0;

      for (const line of lines) {
        const t = line.trim();
        if (!t) continue;
        total++;
        let english = "";
        let valathi = "";

        const eqIdx = t.indexOf("=");
        const dashIdx = (eqIdx === -1) ? t.indexOf("-") : -1;

        if (eqIdx !== -1) {
          english = t.slice(0, eqIdx).trim();
          valathi = t.slice(eqIdx + 1).trim();
        } else if (dashIdx !== -1) {
          english = t.slice(0, dashIdx).trim();
          valathi = t.slice(dashIdx + 1).trim();
        } else {
          english = t;
          valathi = t;
        }

        if (!english || !valathi) continue;
        const key = `${english.toLowerCase()}|${valathi.toLowerCase()}`;
        if (!map.has(key)) {
          map.set(key, { english, valathi });
        }
      }

      const items = Array.from(map.values());
      const duplicates = Math.max(0, total - items.length);
      return { items, duplicates };
    }

    function mergeLexiconEntries(existing, incoming) {
      const map = new Map();
      if (Array.isArray(existing)) {
        for (const e of existing) {
          if (!e || !e.english || !e.valathi) continue;
          const key = `${String(e.english).toLowerCase()}|${String(e.valathi).toLowerCase()}`;
          map.set(key, { english: e.english, valathi: e.valathi });
        }
      }
      if (Array.isArray(incoming)) {
        for (const e of incoming) {
          if (!e || !e.english || !e.valathi) continue;
          const key = `${String(e.english).toLowerCase()}|${String(e.valathi).toLowerCase()}`;
          map.set(key, { english: e.english, valathi: e.valathi });
        }
      }
      return Array.from(map.values());
    }

    function extractTokensFromPatterns(patterns) {
      const tokenSet = new Set();
      const tokenRegex = /\{([^}]+)\}/g;
      for (const p of patterns) {
        let m;
        while ((m = tokenRegex.exec(p)) !== null) {
          const token = m[1].trim();
          if (token) tokenSet.add(token);
        }
      }
      return Array.from(tokenSet);
    }

    // --------------------------------
    // FOLDER STATE
    // --------------------------------
    function loadFolderState() {
      try {
        const raw = window.localStorage.getItem(FOLDER_STATE_KEY);
        if (!raw) return {};
        const parsed = JSON.parse(raw);
        return parsed && typeof parsed === "object" ? parsed : {};
      } catch {
        return {};
      }
    }

    function saveFolderState() {
      try {
        window.localStorage.setItem(FOLDER_STATE_KEY, JSON.stringify(folderState));
      } catch {}
    }

    // --------------------------------
    // GENERATOR STORAGE
    // --------------------------------
    function seedInitialGenerators() {
      // fixed ids so templates can refer to these
      const elfStartId = "seed-elf-starts";
      const elfMiddleId = "seed-elf-middles";
      const elfEndSoftId = "seed-elf-ends-soft";
      const elfEndSharpId = "seed-elf-ends-sharp";
      const bookAdjId = "seed-book-adj";
      const bookNounId = "seed-book-noun";
      const bookPlaceId = "seed-book-place";

      return [
        // simple lists used by templates
        {
          id: elfStartId,
          folder: "Names",
          name: "Elf Name Starts",
          type: "list",
          items: [
            "Val","Ves","Vor","Vrae","Sel","Thal","Mir","Nor","Lae","Vel","Vyn","Maer",
            "Ael","Ny","Syl","Cae","Ari","Eli","Var","Lor","Sael","Cal","Ser","Ty","Vael","Oryn"
          ]
        },
        {
          id: elfMiddleId,
          folder: "Names",
          name: "Elf Name Middles",
          type: "list",
          items: [
            "a","e","i","o","la","le","li","ra","re","ri","sa","se","thal","lyn","rin"
          ]
        },
        {
          id: elfEndSoftId,
          folder: "Names",
          name: "Elf Name Ends (Soft)",
          type: "list",
          items: [
            "a","ae","ira","iel","essa","yn","yne","ara","ina"
          ]
        },
        {
          id: elfEndSharpId,
          folder: "Names",
          name: "Elf Name Ends (Sharp)",
          type: "list",
          items: [
            "as","ix","or","eth","is","ar","ax","an","orix"
          ]
        },
        {
          id: bookAdjId,
          folder: "Names",
          name: "Book Adjectives",
          type: "list",
          items: [
            "Silent","Forgotten","Gilded","Broken","Crimson","Twilight","Shattered",
            "Hidden","Last","Bound","Whispering","Silver","Onyx","Verdant","Burning","Veiled"
          ]
        },
        {
          id: bookNounId,
          folder: "Names",
          name: "Book Nouns",
          type: "list",
          items: [
            "Throne","Forest","Empire","Oath","Crown","River","Sea","Spire",
            "Song","Shadow","Light","Wolf","King","Queen","Chronicle","Blade","Storm","Gate"
          ]
        },
        {
          id: bookPlaceId,
          folder: "Names",
          name: "Book Places (Vrahune)",
          type: "list",
          items: [
            "Vrahune","Val’athanna","Valdora","Fallen Spears","Frostclaw Wilds",
            "Verdant Veil","Onyx Empire","Raven Fields","New Hope Frontier"
          ]
        },
        // advanced templates
        {
          id: "seed-elf-names-template",
          folder: "Names",
          name: "Elf Names (Template)",
          type: "advanced",
          items: {
            patterns: [
              "{Start}{EndSoft}",
              "{Start}{Middle}{EndSoft}",
              "{Start}{EndSharp}",
              "{Start}{Middle}{EndSharp}"
            ],
            tokenMap: {
              Start: elfStartId,
              Middle: elfMiddleId,
              EndSoft: elfEndSoftId,
              EndSharp: elfEndSharpId
            }
          }
        },
        {
          id: "seed-book-titles-template",
          folder: "Names",
          name: "Book Titles (Template)",
          type: "advanced",
          items: {
            patterns: [
              "The {Adj} {Noun}",
              "The {Adj} {Noun} of {Place}",
              "{Noun} of {Place}",
              "{Place}: The {Adj} {Noun}"
            ],
            tokenMap: {
              Adj: bookAdjId,
              Noun: bookNounId,
              Place: bookPlaceId
            }
          }
        },
        // lexicon
        {
          id: "gen-lex-valathi",
          folder: "Lexicons",
          name: "Valathi Lexicon",
          type: "lexicon",
          items: valathiLexiconSeed
        }
      ];
    }

    function loadGenerators() {
      try {
        const raw = window.localStorage.getItem(GEN_STORAGE_KEY);
        if (!raw) return [];
        const parsed = JSON.parse(raw);
        if (!Array.isArray(parsed)) return [];
        return parsed.map(g => {
          const type = g.type || "list";
          let items = g.items;
          if (type === "list") {
            items = Array.isArray(items) ? items : [];
          } else if (type === "lexicon") {
            items = Array.isArray(items) ? items : [];
          } else if (type === "advanced") {
            if (!items || typeof items !== "object") {
              items = { patterns: [], tokenMap: {} };
            } else {
              items.patterns = Array.isArray(items.patterns) ? items.patterns : [];
              items.tokenMap = items.tokenMap && typeof items.tokenMap === "object" ? items.tokenMap : {};
            }
          }
          return { ...g, type, items };
        });
      } catch {
        return [];
      }
    }

    function saveGenerators(list) {
      try {
        window.localStorage.setItem(GEN_STORAGE_KEY, JSON.stringify(list));
      } catch {}
    }

    // --------------------------------
    // FOLDER SELECT (create/edit)
    // --------------------------------
    function populateFolderSelect(selectedFolder) {
      const select = document.getElementById("genFolderSelect");
      if (!select) return;

      const gens = loadGenerators();
      const folderSet = new Set();

      gens.forEach(g => {
        const f = g.folder || "General";
        folderSet.add(f);
      });

      const folderNames = Array.from(folderSet).sort((a, b) => a.localeCompare(b));

      if (selectedFolder && selectedFolder !== "__new__" && !folderSet.has(selectedFolder)) {
        folderNames.push(selectedFolder);
      }

      select.innerHTML = "";

      folderNames.forEach(f => {
        const opt = document.createElement("option");
        opt.value = f;
        opt.textContent = f;
        select.appendChild(opt);
      });

      const optNew = document.createElement("option");
      optNew.value = "__new__";
      optNew.textContent = "+ New folder…";
      select.appendChild(optNew);

      if (selectedFolder && selectedFolder !== "__new__" && folderNames.includes(selectedFolder)) {
        select.value = selectedFolder;
      } else if (folderNames.length > 0) {
        select.value = folderNames[0];
      } else {
        select.value = "__new__";
      }

      handleFolderSelectChange();
    }

    function handleFolderSelectChange() {
      const select = document.getElementById("genFolderSelect");
      const newInput = document.getElementById("genFolderNewInput");
      if (!select || !newInput) return;

      if (select.value === "__new__") {
        newInput.style.display = "block";
      } else {
        newInput.style.display = "none";
        newInput.value = "";
      }
    }

    // --------------------------------
    // NAV RENDERING (with collapse & rename)
    // --------------------------------
    function renderGeneratorNav() {
      const nav = document.getElementById("generatorNav");
      nav.innerHTML = "";

      const gens = loadGenerators();
      const folderMap = {};

      gens.forEach(gen => {
        const folder = gen.folder || "General";
        if (!folderMap[folder]) folderMap[folder] = [];
        folderMap[folder].push(gen);
      });

      const folderNames = Object.keys(folderMap).sort((a, b) => a.localeCompare(b));

      if (!folderNames.length) {
        nav.innerHTML = `<div class="muted" style="font-size:0.8rem; padding:4px 4px 8px;">No generators yet. Click ＋ to create one.</div>`;
        return;
      }

      folderNames.forEach(folder => {
        const gensInFolder = folderMap[folder].sort((a,b) => a.name.localeCompare(b.name));
        const count = gensInFolder.length;

        const collapsed = folderState[folder] && folderState[folder].collapsed;

        const heading = document.createElement("div");
        heading.className = "nav-folder-heading";
        heading.dataset.folder = folder;
        heading.innerHTML = `
          <span class="folder-toggle">
            <span class="folder-arrow">${collapsed ? "▸" : "▾"}</span>
            <span class="folder-label">${folder}</span>
            <span class="folder-badge">(${count})</span>
          </span>
          <button class="folder-rename-btn btn-secondary btn-small" type="button">✎</button>
        `;
        nav.appendChild(heading);

        if (!collapsed) {
          gensInFolder.forEach(gen => {
            const item = document.createElement("div");
            item.className = "nav-generator";
            item.dataset.id = gen.id;

            const isActive = activeGenerator && activeGenerator.id === gen.id;
            if (isActive) item.classList.add("active");

            item.innerHTML = `<span class="name">${gen.name}</span>`;
            nav.appendChild(item);
          });
        }
      });
    }

    // --------------------------------
    // ACTIVE GENERATOR PANEL
    // --------------------------------
    function renderActiveGeneratorPanel() {
      const label = document.getElementById("activeGeneratorLabel");
      const panel = document.getElementById("generatorPanel");
      panel.innerHTML = "";
      panel.removeEventListener("click", handleCopyClick);

      if (!activeGenerator) {
        label.textContent = "No generator selected";
        panel.innerHTML = `<div class="muted">Choose a generator from the left, or click ＋ to create one.</div>`;
        return;
      }

      const gens = loadGenerators();
      const gen = gens.find(g => g.id === activeGenerator.id);
      if (!gen) {
        label.textContent = "Generator not found";
        panel.innerHTML = `<div class="muted">This generator no longer exists. Choose another one.</div>`;
        return;
      }

      label.textContent = `${gen.name} (${gen.folder || "General"})`;

      // LIST GENERATOR
      if (gen.type === "list") {
        panel.innerHTML = `
          <div class="generator-title-main">
            ${gen.name}
          </div>
          <div class="muted" style="margin-bottom:8px;">
            Folder: ${gen.folder || "General"} · ${gen.items.length} items in pool.
          </div>
          <div class="row">
            <div class="col">
              <label for="customCountInput">Count</label>
              <input id="customCountInput" type="number" min="1" max="50" value="10">
            </div>
            <div class="col">
              <label>&nbsp;</label>
              <button id="customGenerateBtn" class="btn-primary">Generate</button>
            </div>
          </div>
          <div class="row">
            <button id="customEditBtn" class="btn-secondary btn-small">Edit items</button>
            <button id="customDeleteBtn" class="btn-secondary btn-small">Delete generator</button>
          </div>
          <div id="customResults" class="generated-list"></div>
        `;

        const countInput = panel.querySelector("#customCountInput");
        const genBtn = panel.querySelector("#customGenerateBtn");
        const editBtn = panel.querySelector("#customEditBtn");
        const delBtn  = panel.querySelector("#customDeleteBtn");
        const results = panel.querySelector("#customResults");

        genBtn.addEventListener("click", () => {
          const pool = [...gen.items];
          const count = Math.max(1, Math.min(50, parseInt(countInput.value || "1", 10)));
          results.innerHTML = "";
          const frag = document.createDocumentFragment();
          if (!pool.length) return;
          for (let i = 0; i < count; i++) {
            if (!pool.length) break;
            const idx = Math.floor(Math.random() * pool.length);
            const value = pool.splice(idx, 1)[0];
            const div = document.createElement("div");
            div.className = "generated-item";
            div.textContent = value;
            frag.appendChild(div);
          }
          results.appendChild(frag);
        });

        results.addEventListener("click", handleCopyClick);

        editBtn.addEventListener("click", () => {
          openEditGeneratorBox(gen.id);
        });

        delBtn.addEventListener("click", () => {
          const ok = window.confirm(`Delete generator “${gen.name}” from folder “${gen.folder || "General"}”?`);
          if (!ok) return;
          const newList = gens.filter(g => g.id !== gen.id);
          saveGenerators(newList);
          if (activeGenerator && activeGenerator.id === gen.id) {
            activeGenerator = null;
          }
          renderGeneratorNav();
          renderActiveGeneratorPanel();
        });

        return;
      }

      // LEXICON GENERATOR
      if (gen.type === "lexicon") {
        panel.innerHTML = `
          <div class="generator-title-main">
            ${gen.name}
          </div>
          <div class="muted" style="margin-bottom:8px;">
            Folder: ${gen.folder || "General"} · ${gen.items.length} lexicon entries.
          </div>

          <div class="row">
            <div class="col">
              <label for="lexMode">Direction</label>
              <select id="lexMode">
                <option value="en-to-va">Common → Valathi</option>
                <option value="va-to-en">Valathi → Common</option>
              </select>
            </div>
            <div class="col">
              <label for="lexQuery">Word</label>
              <input id="lexQuery" type="text" placeholder="Type a word to look up">
            </div>
            <div class="col">
              <label>&nbsp;</label>
              <button id="lexSearchBtn" class="btn-primary">Translate</button>
            </div>
          </div>

          <div id="lexResult" class="generated-list"></div>

          <hr>

          <div class="section-title">
            <span>Manage entries</span>
          </div>
          <div class="row">
            <div class="col">
              <label for="lexiconAddInput">Add entries (english = valathi)</label>
              <textarea id="lexiconAddInput" placeholder="high = val&#10;forest = ’ath"></textarea>
            </div>
          </div>
          <div class="row">
            <button id="lexAppendBtn" class="btn-secondary btn-small">Append from text</button>
            <button id="lexImportBtn" class="btn-secondary btn-small">Import from JSON/HTML</button>
            <button id="lexDownloadBtn" class="btn-secondary btn-small">Download JSON</button>
            <button id="lexOpenEditBtn" class="btn-secondary btn-small">Edit as raw</button>
            <button id="lexDeleteBtn" class="btn-secondary btn-small">Delete generator</button>
          </div>
          <input type="file" id="lexFileInput" accept=".json,.txt,.html" style="display:none;">
          <div id="lexMessage" class="muted" style="margin-top:4px;"></div>

          <div class="section-title" style="margin-top:10px;">
            <span>All entries</span>
            <span class="muted" style="font-size:0.75rem;">Click to copy "english = valathi"</span>
          </div>
          <div id="lexAllEntries" class="generated-list"></div>
        `;

        const lexMode = panel.querySelector("#lexMode");
        const lexQuery = panel.querySelector("#lexQuery");
        const lexSearchBtn = panel.querySelector("#lexSearchBtn");
        const lexResult = panel.querySelector("#lexResult");
        const lexAllEntries = panel.querySelector("#lexAllEntries");
        const lexAddInput = panel.querySelector("#lexiconAddInput");
        const lexAppendBtn = panel.querySelector("#lexAppendBtn");
        const lexImportBtn = panel.querySelector("#lexImportBtn");
        const lexDownloadBtn = panel.querySelector("#lexDownloadBtn");
        const lexFileInput = panel.querySelector("#lexFileInput");
        const lexMessage = panel.querySelector("#lexMessage");
        const lexOpenEditBtn = panel.querySelector("#lexOpenEditBtn");
        const lexDeleteBtn = panel.querySelector("#lexDeleteBtn");

        function renderAllEntriesList(items) {
          lexAllEntries.innerHTML = "";
          const sorted = [...items].sort((a, b) =>
            String(a.english).localeCompare(String(b.english))
          );
          const frag = document.createDocumentFragment();
          for (const e of sorted) {
            const div = document.createElement("div");
            div.className = "generated-item";
            div.textContent = `${e.english} = ${e.valathi}`;
            frag.appendChild(div);
          }
          lexAllEntries.appendChild(frag);
        }

        function searchLexicon(items, query, mode) {
          const q = query.trim().toLowerCase();
          if (!q) return [];
          if (mode === "en-to-va") {
            return items.filter(e => String(e.english).toLowerCase().includes(q));
          } else {
            return items.filter(e => String(e.valathi).toLowerCase().includes(q));
          }
        }

        function doSearch() {
          const gensCurrent = loadGenerators();
          const g = gensCurrent.find(x => x.id === gen.id);
          if (!g) return;

          const items = Array.isArray(g.items) ? g.items : [];
          const mode = lexMode.value;
          const q = lexQuery.value;
          const matches = searchLexicon(items, q, mode);
          lexResult.innerHTML = "";

          if (!q.trim()) {
            lexResult.innerHTML = `<div class="muted">Type a word and click Translate.</div>`;
            return;
          }

          if (!matches.length) {
            lexResult.innerHTML = `<div class="muted">No entries found for "${q}".</div>`;
            return;
          }

          const frag = document.createDocumentFragment();
          for (const e of matches) {
            const div = document.createElement("div");
            div.className = "generated-item";
            if (mode === "en-to-va") {
              div.textContent = `${e.english} → ${e.valathi}`;
            } else {
              div.textContent = `${e.valathi} → ${e.english}`;
            }
            frag.appendChild(div);
          }
          lexResult.appendChild(frag);
        }

        lexSearchBtn.addEventListener("click", doSearch);
        lexQuery.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            doSearch();
          }
        });

        lexResult.addEventListener("click", handleCopyClick);
        lexAllEntries.addEventListener("click", handleCopyClick);

        // Append from text
        lexAppendBtn.addEventListener("click", () => {
          const raw = lexAddInput.value || "";
          if (!raw.trim()) {
            lexMessage.textContent = "No text to append.";
            return;
          }
          const { items: newItems, duplicates } = parseLexiconText(raw);
          if (!newItems.length) {
            lexMessage.textContent = "No valid entries found. Use 'english = valathi'.";
            return;
          }
          const gensCurrent = loadGenerators();
          const idx = gensCurrent.findIndex(x => x.id === gen.id);
          if (idx === -1) return;
          const before = Array.isArray(gensCurrent[idx].items) ? gensCurrent[idx].items : [];
          const merged = mergeLexiconEntries(before, newItems);
          const added = merged.length - before.length;

          gensCurrent[idx].items = merged;
          saveGenerators(gensCurrent);
          lexAddInput.value = "";

          lexMessage.textContent =
            `Appended ${added} entries. ${duplicates > 0 ? duplicates + " duplicate lines removed." : "No duplicates in input."}`;
          renderAllEntriesList(merged);
        });

        // Import
        lexImportBtn.addEventListener("click", () => {
          lexFileInput.value = "";
          lexFileInput.click();
        });

        lexFileInput.addEventListener("change", (e) => {
          const file = e.target.files && e.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = (ev) => {
            const text = ev.target.result;
            let imported = [];

            try {
              const parsed = JSON.parse(text);
              if (Array.isArray(parsed)) {
                for (const item of parsed) {
                  if (!item) continue;
                  if (typeof item === "string") {
                    const { items } = parseLexiconText(item);
                    imported = imported.concat(items);
                  } else if (typeof item === "object") {
                    const english = item.english || item.en || item.word || item.key || "";
                    const valathi = item.valathi || item.va || item.value || "";
                    if (english && valathi) {
                      imported.push({ english, valathi });
                    }
                  }
                }
              } else if (typeof parsed === "object") {
                for (const key in parsed) {
                  if (!Object.prototype.hasOwnProperty.call(parsed, key)) continue;
                  const english = key;
                  const valathi = parsed[key];
                  if (english && valathi) {
                    imported.push({ english, valathi });
                  }
                }
              }
            } catch {
              const { items } = parseLexiconText(text);
              imported = imported.concat(items);
            }

            if (!imported.length) {
              lexMessage.textContent = "No valid entries found in file.";
              return;
            }

            const gensCurrent = loadGenerators();
            const idx = gensCurrent.findIndex(x => x.id === gen.id);
            if (idx === -1) return;

            const before = Array.isArray(gensCurrent[idx].items) ? gensCurrent[idx].items : [];
            const merged = mergeLexiconEntries(before, imported);
            const added = merged.length - before.length;

            gensCurrent[idx].items = merged;
            saveGenerators(gensCurrent);
            lexMessage.textContent = `Imported ${added} new entries from file.`;
            renderAllEntriesList(merged);
          };
          reader.readAsText(file);
        });

        // Download JSON
        lexDownloadBtn.addEventListener("click", () => {
          const gensCurrent = loadGenerators();
          const g = gensCurrent.find(x => x.id === gen.id);
          if (!g) return;
          const dataStr = JSON.stringify(g.items || [], null, 2);
          const blob = new Blob([dataStr], { type: "application/json" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `${g.name.replace(/\s+/g, "_")}.json`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        });

        // Open raw edit (left box)
        lexOpenEditBtn.addEventListener("click", () => {
          openEditGeneratorBox(gen.id);
        });

        // Delete
        lexDeleteBtn.addEventListener("click", () => {
          const ok = window.confirm(`Delete generator “${gen.name}” from folder “${gen.folder || "General"}”?`);
          if (!ok) return;
          const newList = gens.filter(g => g.id !== gen.id);
          saveGenerators(newList);
          if (activeGenerator && activeGenerator.id === gen.id) {
            activeGenerator = null;
          }
          renderGeneratorNav();
          renderActiveGeneratorPanel();
        });

        renderAllEntriesList(gen.items || []);
        return;
      }

      // ADVANCED GENERATOR
      if (gen.type === "advanced") {
        const items = gen.items || { patterns: [], tokenMap: {} };
        const patterns = Array.isArray(items.patterns) ? items.patterns : [];
        const tokenMap = items.tokenMap && typeof items.tokenMap === "object" ? items.tokenMap : {};

        const patternsText = patterns.join("\n");
        const allTokens = extractTokensFromPatterns(patterns);

        panel.innerHTML = `
          <div class="generator-title-main">
            ${gen.name}
          </div>
          <div class="muted" style="margin-bottom:8px;">
            Advanced generator that stitches together outputs from your other generators using simple patterns.
          </div>

          <!-- TOP: Generate controls + results -->
          <div class="row">
            <div class="col">
              <label for="advCountInput">Count</label>
              <input id="advCountInput" type="number" min="1" max="50" value="10">
            </div>
            <div class="col">
              <label>&nbsp;</label>
              <button id="advGenerateBtn" class="btn-primary">Generate</button>
            </div>
          </div>

          <div id="advResults" class="generated-list"></div>

          <hr>

          <!-- BOTTOM: Template settings (collapsible) -->
          <div class="section-title">
            <span>Template settings</span>
            <button id="advToggleConfigBtn" class="btn-secondary btn-small">Edit template</button>
          </div>

          <div id="advConfig" style="display:none;">
            <div class="muted" style="font-size:0.8rem; line-height:1.4; margin-bottom:6px;">
              Tips:
              <ul style="margin:4px 0 0 18px; padding:0; list-style:disc;">
                <li>Write patterns using placeholders in braces, e.g. <code>{Name}</code>, <code>{Race}</code>, <code>{Place}</code>.</li>
                <li>Each placeholder (token) pulls from one of your existing <b>list</b> generators.</li>
                <li>Example pattern: <code>{Name} is a {Race} from {Hometown}, known for {Trait}.</code></li>
              </ul>
            </div>

            <div class="row">
              <div class="col">
                <label for="advPatternsInput">Patterns (one per line)</label>
                <textarea id="advPatternsInput" placeholder="{Name} is a {Race} from {Hometown}, known for {Trait}.">${patternsText}</textarea>
              </div>
            </div>

            <div class="section-title" style="margin-top:4px;">
              <span>Token mappings</span>
              <span class="muted" style="font-size:0.75rem;">Tokens are auto-detected from the patterns above</span>
            </div>

            <div id="advTokensContainer"></div>

            <div class="row" style="margin-top:8px;">
              <button id="advSaveBtn" class="btn-primary btn-small">Save template</button>
              <button id="advDeleteBtn" class="btn-secondary btn-small">Delete generator</button>
            </div>
          </div>
        `;

        const advCountInput = panel.querySelector("#advCountInput");
        const advGenerateBtn = panel.querySelector("#advGenerateBtn");
        const advResults = panel.querySelector("#advResults");
        const advToggleConfigBtn = panel.querySelector("#advToggleConfigBtn");
        const advConfig = panel.querySelector("#advConfig");
        const advPatternsInput = panel.querySelector("#advPatternsInput");
        const advTokensContainer = panel.querySelector("#advTokensContainer");
        const advSaveBtn = panel.querySelector("#advSaveBtn");
        const advDeleteBtn = panel.querySelector("#advDeleteBtn");

        function renderTokenMappings(currentTokens, currentMap) {
          if (!currentTokens.length) {
            advTokensContainer.innerHTML = `<div class="muted" style="margin-top:4px;">No tokens found yet. Add <code>{Token}</code> placeholders to your patterns above.</div>`;
            return;
          }
          const gensAll = loadGenerators();
          const listGenerators = gensAll.filter(g => g.type === "list");
          const table = document.createElement("table");
          table.className = "token-table";
          table.innerHTML = `
            <thead>
              <tr>
                <th style="width:20%;">Token</th>
                <th>Source generator (list)</th>
              </tr>
            </thead>
            <tbody></tbody>
          `;
          const tbody = table.querySelector("tbody");

          currentTokens.forEach(token => {
            const tr = document.createElement("tr");
            const mappedId = currentMap[token] || "";
            const selectHtmlOptions = [
              `<option value="">— none —</option>`,
              ...listGenerators.map(g => `<option value="${g.id}">${g.name}</option>`)
            ].join("");
            tr.innerHTML = `
              <td>{${token}}</td>
              <td>
                <select class="adv-token-select" data-token="${token}">
                  ${selectHtmlOptions}
                </select>
              </td>
            `;
            tbody.appendChild(tr);
          });

          advTokensContainer.innerHTML = "";
          advTokensContainer.appendChild(table);

          const selects = advTokensContainer.querySelectorAll(".adv-token-select");
          selects.forEach(sel => {
            const tok = sel.dataset.token;
            const mappedId = currentMap[tok] || "";
            if (mappedId) {
              sel.value = mappedId;
            }
          });
        }

        // initial token mapping UI (hidden but ready)
        renderTokenMappings(allTokens, tokenMap);

        // toggle template config visibility
        advToggleConfigBtn.addEventListener("click", () => {
          const isHidden = advConfig.style.display === "none";
          advConfig.style.display = isHidden ? "block" : "none";
          advToggleConfigBtn.textContent = isHidden ? "Hide template" : "Edit template";
        });

        // save template
        advSaveBtn.addEventListener("click", () => {
          const rawPatterns = (advPatternsInput.value || "").split(/\r?\n/).map(s => s.trim()).filter(Boolean);
          const newTokens = extractTokensFromPatterns(rawPatterns);

          const newTokenMap = {};
          const selects = advTokensContainer.querySelectorAll(".adv-token-select");
          selects.forEach(sel => {
            const tok = sel.dataset.token;
            const val = sel.value || "";
            if (tok && val) {
              newTokenMap[tok] = val;
            }
          });

          const gensCurrent = loadGenerators();
          const idx = gensCurrent.findIndex(x => x.id === gen.id);
          if (idx === -1) return;

          gensCurrent[idx].items = {
            patterns: rawPatterns,
            tokenMap: newTokenMap
          };
          saveGenerators(gensCurrent);

          renderTokenMappings(newTokens, newTokenMap);

          const msg = document.getElementById("copyMessage");
          msg.textContent = `Template saved with ${rawPatterns.length} pattern(s) and ${Object.keys(newTokenMap).length} mapped token(s).`;
          setTimeout(() => {
            msg.textContent = "Click any generated item or lexicon entry to copy.";
          }, 2500);
        });

        // delete advanced generator
        advDeleteBtn.addEventListener("click", () => {
          const gensCurrent = loadGenerators();
          const ok = window.confirm(`Delete generator “${gen.name}” from folder “${gen.folder || "General"}”?`);
          if (!ok) return;
          const newList = gensCurrent.filter(g => g.id !== gen.id);
          saveGenerators(newList);
          if (activeGenerator && activeGenerator.id === gen.id) {
            activeGenerator = null;
          }
          renderGeneratorNav();
          renderActiveGeneratorPanel();
        });

        // generate from template
        advGenerateBtn.addEventListener("click", () => {
          const gensCurrent = loadGenerators();
          const g = gensCurrent.find(x => x.id === gen.id);
          if (!g || g.type !== "advanced") return;
          const advItems = g.items || { patterns: [], tokenMap: {} };
          const patterns = Array.isArray(advItems.patterns) ? advItems.patterns : [];
          const tMap = advItems.tokenMap && typeof advItems.tokenMap === "object" ? advItems.tokenMap : {};

          advResults.innerHTML = "";
          if (!patterns.length) {
            advResults.innerHTML = `<div class="muted">No patterns defined yet. Open “Edit template” below and add lines using {Tokens}.</div>`;
            return;
          }

          const count = Math.max(1, Math.min(50, parseInt(advCountInput.value || "1", 10)));
          const gensLatest = loadGenerators();
          const genById = {};
          gensLatest.forEach(x => { genById[x.id] = x; });

          const frag = document.createDocumentFragment();

          for (let i = 0; i < count; i++) {
            let pattern = rand(patterns);
            const tokens = extractTokensFromPatterns([pattern]);
            let result = pattern;

            tokens.forEach(tok => {
              const sourceId = tMap[tok];
              const sourceGen = genById[sourceId];
              if (!sourceGen || sourceGen.type !== "list" || !Array.isArray(sourceGen.items) || !sourceGen.items.length) {
                return;
              }
              const value = rand(sourceGen.items);
              const re = new RegExp("\\{" + tok.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\$&') + "\\}", "g");
              result = result.replace(re, value);
            });

            const div = document.createElement("div");
            div.className = "generated-item";
            div.textContent = result;
            frag.appendChild(div);
          }

          advResults.appendChild(frag);
          advResults.addEventListener("click", handleCopyClick);
        });

        return;
      }

      // fallback
      panel.innerHTML = `<div class="muted">Unknown generator type.</div>`;
    }

    // --------------------------------
    // CREATE / EDIT GENERATOR BOX
    // --------------------------------
    function openNewGeneratorBox() {
      editingGeneratorId = null;
      const box = document.getElementById("generatorCreateBox");
      const msg = document.getElementById("generatorCreateMessage");
      const nameInput   = document.getElementById("genNameInput");
      const itemsInput  = document.getElementById("genItemsInput");
      const saveBtn     = document.getElementById("saveGeneratorBtn");
      const expandBtn   = document.getElementById("expandItemsBtn");
      const typeInput   = document.getElementById("genTypeInput");
      const newFolderInput = document.getElementById("genFolderNewInput");
      const itemsRow = document.getElementById("genItemsRow");

      populateFolderSelect("General");

      nameInput.value = "";
      itemsInput.value = "";
      itemsInput.classList.remove("items-expanded");
      itemsExpanded = false;
      expandBtn.textContent = "Expand list editor";
      msg.textContent = "";
      msg.classList.remove("danger");
      saveBtn.textContent = "Save generator";
      typeInput.disabled = false;
      typeInput.value = "list";
      newFolderInput.value = "";
      newFolderInput.style.display = "none";

      itemsRow.style.display = "block";

      box.style.display = "block";
    }

    function openEditGeneratorBox(genId) {
      const gens = loadGenerators();
      const gen = gens.find(g => g.id === genId);
      if (!gen) return;

      editingGeneratorId = genId;
      const box = document.getElementById("generatorCreateBox");
      const msg = document.getElementById("generatorCreateMessage");
      const nameInput   = document.getElementById("genNameInput");
      const itemsInput  = document.getElementById("genItemsInput");
      const saveBtn     = document.getElementById("saveGeneratorBtn");
      const expandBtn   = document.getElementById("expandItemsBtn");
      const typeInput   = document.getElementById("genTypeInput");
      const newFolderInput = document.getElementById("genFolderNewInput");
      const itemsRow = document.getElementById("genItemsRow");

      populateFolderSelect(gen.folder || "General");

      nameInput.value   = gen.name || "";
      msg.textContent = "";
      msg.classList.remove("danger");

      if (gen.type === "lexicon") {
        const arr = Array.isArray(gen.items) ? gen.items : [];
        itemsInput.value = arr.map(e => `${e.english} = ${e.valathi}`).join("\n");
        itemsRow.style.display = "block";
      } else if (gen.type === "list") {
        const arr = Array.isArray(gen.items) ? gen.items : [];
        itemsInput.value = arr.join("\n");
        itemsRow.style.display = "block";
      } else {
        itemsInput.value = "";
        itemsRow.style.display = "none";
      }

      itemsInput.classList.remove("items-expanded");
      itemsExpanded = false;
      expandBtn.textContent = "Expand list editor";

      saveBtn.textContent = "Save changes";

      typeInput.disabled = true;
      typeInput.value = gen.type;
      newFolderInput.value = "";
      newFolderInput.style.display = "none";

      box.style.display = "block";
    }

    function hideGeneratorCreateBox() {
      const box = document.getElementById("generatorCreateBox");
      const msg = document.getElementById("generatorCreateMessage");
      const itemsInput  = document.getElementById("genItemsInput");
      const expandBtn   = document.getElementById("expandItemsBtn");
      const newFolderInput = document.getElementById("genFolderNewInput");

      document.getElementById("genNameInput").value = "";
      itemsInput.value = "";
      msg.textContent = "";
      msg.classList.remove("danger");
      editingGeneratorId = null;

      itemsInput.classList.remove("items-expanded");
      itemsExpanded = false;
      expandBtn.textContent = "Expand list editor";
      newFolderInput.value = "";
      newFolderInput.style.display = "none";

      box.style.display = "none";
    }

    function handleSaveGenerator() {
      const folderSelect = document.getElementById("genFolderSelect");
      const folderNewInput = document.getElementById("genFolderNewInput");
      const nameInput   = document.getElementById("genNameInput");
      const itemsInput  = document.getElementById("genItemsInput");
      const msg         = document.getElementById("generatorCreateMessage");
      const typeInput   = document.getElementById("genTypeInput");

      const typeValue = typeInput.value || "list";

      let folder = "";
      if (folderSelect.value === "__new__") {
        folder = (folderNewInput.value || "").trim() || "General";
      } else {
        folder = folderSelect.value || "General";
      }

      const name   = (nameInput.value || "").trim();
      const raw    = itemsInput.value || "";

      if (!name) {
        msg.textContent = "Please enter a name for the generator.";
        msg.classList.add("danger");
        return;
      }

      const gens = loadGenerators();

      if (editingGeneratorId) {
        const idx = gens.findIndex(g => g.id === editingGeneratorId);
        if (idx === -1) return;

        const existingType = gens[idx].type || "list";

        gens[idx].folder = folder;
        gens[idx].name   = name;

        if (existingType === "list" || existingType === "lexicon") {
          let parsed;
          if (existingType === "lexicon") {
            parsed = parseLexiconText(raw);
          } else {
            parsed = parseGeneratorItems(raw);
          }

          if (!parsed.items.length) {
            msg.textContent = existingType === "lexicon"
              ? "Please provide at least one valid 'english = valathi' entry."
              : "Please provide at least one non-empty item.";
            msg.classList.add("danger");
            return;
          }

          gens[idx].items  = parsed.items;
          gens[idx].type   = existingType;

          saveGenerators(gens);
          msg.classList.remove("danger");
          msg.textContent = `Updated “${name}” with ${parsed.items.length} entries. ${
            parsed.duplicates > 0 ? parsed.duplicates + " duplicates removed." : "No duplicates detected."
          }`;
        } else {
          saveGenerators(gens);
          msg.classList.remove("danger");
          msg.textContent = `Updated “${name}” (advanced generator). Edit patterns & tokens in the main panel.`;
        }

        activeGenerator = { id: editingGeneratorId };
        editingGeneratorId = null;
      } else {
        // new generator
        if (typeValue === "advanced") {
          const id = "gen-" + Date.now() + "-" + Math.floor(Math.random() * 10000);
          gens.push({
            id,
            folder,
            name,
            type: "advanced",
            items: { patterns: [], tokenMap: {} }
          });
          saveGenerators(gens);
          msg.classList.remove("danger");
          msg.textContent = `Saved advanced generator “${name}” in folder “${folder}”. Configure patterns & token mappings in the main panel.`;
          activeGenerator = { id };
        } else {
          let parsed;
          if (typeValue === "lexicon") {
            parsed = parseLexiconText(raw);
          } else {
            parsed = parseGeneratorItems(raw);
          }

          if (!parsed.items.length) {
            msg.textContent = typeValue === "lexicon"
              ? "Please provide at least one valid 'english = valathi' entry."
              : "Please provide at least one non-empty item.";
            msg.classList.add("danger");
            return;
          }

          const id = "gen-" + Date.now() + "-" + Math.floor(Math.random() * 10000);
          gens.push({ id, folder, name, type: typeValue, items: parsed.items });
          saveGenerators(gens);
          msg.classList.remove("danger");
          msg.textContent = `Saved “${name}” in folder “${folder}” with ${parsed.items.length} entries. ${
            parsed.duplicates > 0 ? parsed.duplicates + " duplicates removed." : "No duplicates detected."
          }`;
          activeGenerator = { id };
        }
      }

      renderGeneratorNav();
      renderActiveGeneratorPanel();

      setTimeout(() => {
        hideGeneratorCreateBox();
      }, 1200);
    }

    function toggleItemsExpand() {
      const ta = document.getElementById("genItemsInput");
      const btn = document.getElementById("expandItemsBtn");
      itemsExpanded = !itemsExpanded;
      if (itemsExpanded) {
        ta.classList.add("items-expanded");
        btn.textContent = "Collapse list editor";
      } else {
        ta.classList.remove("items-expanded");
        btn.textContent = "Expand list editor";
      }
    }

    // --------------------------------
    // DB DOWNLOAD (full)
    // --------------------------------
    function handleDownloadDatabase() {
      const gens = loadGenerators();
      const dataStr = JSON.stringify(gens, null, 2);
      const blob = new Blob([dataStr], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "vrahune_generators.json";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // --------------------------------
    // NAV CLICK HANDLER (folders & gens)
    // --------------------------------
    function handleNavClick(event) {
      const renameBtn = event.target.closest(".folder-rename-btn");
      if (renameBtn) {
        const heading = renameBtn.closest(".nav-folder-heading");
        if (!heading) return;
        const folder = heading.dataset.folder;
        if (!folder) return;
        const newName = window.prompt("Rename folder:", folder);
        if (!newName) return;
        const trimmed = newName.trim();
        if (!trimmed || trimmed === folder) return;

        const gens = loadGenerators();
        gens.forEach(g => {
          if ((g.folder || "General") === folder) {
            g.folder = trimmed;
          }
        });
        saveGenerators(gens);

        if (folderState[folder]) {
          folderState[trimmed] = folderState[folder];
          delete folderState[folder];
          saveFolderState();
        }

        renderGeneratorNav();
        renderActiveGeneratorPanel();
        populateFolderSelect(trimmed);
        return;
      }

      const folderToggle = event.target.closest(".folder-toggle");
      if (folderToggle) {
        const heading = folderToggle.closest(".nav-folder-heading");
        if (!heading) return;
        const folder = heading.dataset.folder;
        if (!folder) return;
        const current = folderState[folder] && folderState[folder].collapsed;
        if (!folderState[folder]) folderState[folder] = {};
        folderState[folder].collapsed = !current;
        saveFolderState();
        renderGeneratorNav();
        return;
      }

      const genItem = event.target.closest(".nav-generator");
      if (genItem) {
        const id = genItem.dataset.id;
        if (!id) return;
        activeGenerator = { id };
        renderGeneratorNav();
        renderActiveGeneratorPanel();
      }
    }

    // --------------------------------
    // INITIAL LOAD: seed if empty
    // --------------------------------
    async function initApp() {
      folderState = loadFolderState();

      const hasLocal = !!window.localStorage.getItem(GEN_STORAGE_KEY);
      if (!hasLocal) {
        const seeded = seedInitialGenerators();
        saveGenerators(seeded);
      }

      renderGeneratorNav();
      renderActiveGeneratorPanel();
      populateFolderSelect("General");
    }

    // --------------------------------
    // INIT
    // --------------------------------
    document.addEventListener("DOMContentLoaded", () => {
      document.getElementById("generatorNav").addEventListener("click", handleNavClick);
      document.getElementById("addGeneratorBtn").addEventListener("click", openNewGeneratorBox);
      document.getElementById("cancelGeneratorBtn").addEventListener("click", hideGeneratorCreateBox);
      document.getElementById("saveGeneratorBtn").addEventListener("click", handleSaveGenerator);
      document.getElementById("expandItemsBtn").addEventListener("click", toggleItemsExpand);
      document.getElementById("downloadDbBtn").addEventListener("click", handleDownloadDatabase);

      const folderSelect = document.getElementById("genFolderSelect");
      if (folderSelect) {
        folderSelect.addEventListener("change", handleFolderSelectChange);
      }

      initApp();
    });
  </script>
</body>
</html>
