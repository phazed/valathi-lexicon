<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Vrahune Toolbox – Generators & Lexicons</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    :root {
      --bg-main: #050608;
      --bg-panel: #0b0f14;
      --bg-panel-alt: #090d11;
      --bg-nav: #050608;
      --border-subtle: #232a33;
      --accent: #c0c0c0;
      --accent-soft: #808890;
      --accent-strong: #f5f5f5;
      --danger: #ff5c5c;
      --text-main: #e6e6e6;
      --text-muted: #9ba1aa;
      --hover: #151a22;
      --shadow-soft: 0 0 24px rgba(0, 0, 0, 0.7);
      --radius-lg: 14px;
      --radius-md: 10px;
      --radius-sm: 6px;
      --transition-fast: 0.16s ease-out;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
                   "Segoe UI", sans-serif;
      background: radial-gradient(circle at top left, #151921 0, #050608 40%, #000000 100%);
      color: var(--text-main);
      height: 100vh;
      display: flex;
      flex-direction: column;
      -webkit-font-smoothing: antialiased;
    }

    *::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    *::-webkit-scrollbar-track {
      background: #050608;
    }
    *::-webkit-scrollbar-thumb {
      background: #2c323d;
      border-radius: 4px;
    }
    *::-webkit-scrollbar-thumb:hover {
      background: #3a414d;
    }

    .app-shell {
      display: flex;
      flex-direction: column;
      height: 100vh;
      max-width: 1400px;
      margin: 0 auto;
      padding: 10px 12px;
      gap: 8px;
    }

    header.app-header {
      background: linear-gradient(135deg, #0b0f14, #050608);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-subtle);
      box-shadow: var(--shadow-soft);
      padding: 10px 14px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .header-left {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .app-title {
      font-size: 1.1rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--accent-strong);
    }

    .app-subtitle {
      font-size: 0.78rem;
      color: var(--text-muted);
    }

    .header-right {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.8rem;
    }

    .badge {
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      background: #05090f;
      color: var(--accent-soft);
    }

    .btn-primary,
    .btn-secondary,
    .btn-small {
      font-family: inherit;
      font-size: 0.8rem;
      border-radius: 999px;
      border: 1px solid transparent;
      padding: 6px 12px;
      cursor: pointer;
      background: #181f2b;
      color: var(--accent-strong);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      transition: background var(--transition-fast), border-color var(--transition-fast), transform 0.06s ease-out, box-shadow 0.06s ease-out;
    }

    .btn-primary {
      border-color: #818894;
      background: radial-gradient(circle at top, #2a303b, #141821);
    }

    .btn-primary:hover {
      background: radial-gradient(circle at top, #343b46, #171a24);
      box-shadow: 0 0 12px rgba(192, 192, 192, 0.25);
      transform: translateY(-0.5px);
    }

    .btn-secondary {
      border-color: #303641;
      background: #080b11;
      color: var(--text-muted);
    }

    .btn-secondary:hover {
      border-color: #3a414d;
      background: #10141d;
      transform: translateY(-0.5px);
    }

    .btn-small {
      font-size: 0.76rem;
      padding: 3px 8px;
      border-radius: 999px;
    }

    .layout-main {
      display: grid;
      grid-template-columns: 270px minmax(0, 1fr);
      gap: 10px;
      min-height: 0;
      flex: 1;
    }

    aside.sidebar {
      background: var(--bg-nav);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-subtle);
      box-shadow: var(--shadow-soft);
      padding: 10px 8px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-height: 0;
    }

    .sidebar-header {
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 0 4px;
    }

    .sidebar-header-row {
      display: flex;
      gap: 6px;
      align-items: center;
    }

    .sidebar-title {
      font-size: 0.85rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--accent-soft);
    }

    .sidebar-subtitle {
      font-size: 0.7rem;
      color: var(--text-muted);
    }

    .search-input {
      width: 100%;
      padding: 5px 10px;
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      background: #05070c;
      color: var(--text-main);
      font-size: 0.78rem;
    }

    .search-input:focus {
      outline: none;
      border-color: #9aa2af;
      box-shadow: 0 0 0 1px rgba(192,192,192,0.4);
    }

    .nav-scroll {
      flex: 1;
      overflow-y: auto;
      margin-top: 4px;
      padding: 0 2px;
    }

    .sidebar-bottom-tools {
      margin-top: 6px;
    }

    .nav-folder-heading {
      font-size: 0.78rem;
      padding: 3px 6px;
      margin-top: 4px;
      border-radius: var(--radius-md);
      background: linear-gradient(90deg, #070b11, #050608);
      border: 1px solid rgba(59, 69, 83, 0.9);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 4px;
      cursor: pointer;
    }

    .folder-toggle {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .folder-arrow {
      color: var(--accent-soft);
      font-size: 0.7rem;
    }

    .folder-label {
      color: var(--accent-strong);
    }

    .folder-badge {
      font-size: 0.7rem;
      padding: 0 4px;
      border-radius: 999px;
      border: 1px solid #3b4656;
      color: var(--text-muted);
    }

    .folder-rename-btn {
      padding: 2px 6px;
      font-size: 0.7rem;
    }

    .nav-generator {
      font-size: 0.78rem;
      padding: 3px 10px 3px 22px;
      border-radius: var(--radius-md);
      cursor: pointer;
      margin-top: 1px;
      color: var(--text-muted);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 4px;
    }

    .nav-generator:hover {
      background: #151a22;
      color: var(--accent-strong);
    }

    .nav-generator.active {
      background: linear-gradient(135deg, #1f2835, #101720);
      color: var(--accent-strong);
      border: 1px solid #6d7584;
    }

    .nav-generator .name {
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      max-width: 100%;
    }

    section.main-panel {
      background: var(--bg-panel);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-subtle);
      box-shadow: var(--shadow-soft);
      padding: 10px 12px;
      display: grid;
      grid-template-rows: auto minmax(0, 1fr);
      gap: 8px;
      min-height: 0;
    }

    #copyMessage {
      font-size: 0.75rem;
      color: var(--text-muted);
      padding: 2px 4px;
      border-radius: 999px;
      border: 1px solid #222832;
      background: #05070c;
      display: inline-flex;
      align-items: center;
      max-width: 100%;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .generator-panel-wrapper {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-height: 0;
    }

    #activeGeneratorLabel {
      font-size: 0.9rem;
      color: var(--accent-strong);
    }

    #generatorPanel {
      flex: 1;
      min-height: 0;
      border-radius: var(--radius-md);
      border: 1px solid #222832;
      background: radial-gradient(circle at top left, #10151f, #05070c 70%);
      padding: 10px 10px;
      font-size: 0.8rem;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .generator-title-main {
      font-size: 0.95rem;
      font-weight: 600;
      margin-bottom: 2px;
      color: var(--accent-strong);
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 6px;
      align-items: flex-start;
    }

    .col {
      flex: 1;
      min-width: 120px;
    }

    label {
      display: block;
      font-size: 0.75rem;
      color: var(--text-muted);
      margin-bottom: 3px;
    }

    input[type="number"],
    input[type="text"],
    select,
    textarea {
      width: 100%;
      font-family: inherit;
      font-size: 0.8rem;
      padding: 5px 8px;
      border-radius: var(--radius-sm);
      border: 1px solid var(--border-subtle);
      background: #05070c;
      color: var(--text-main);
    }

    textarea {
      resize: vertical;
      min-height: 80px;
    }

    input:focus,
    select:focus,
    textarea:focus {
      outline: none;
      border-color: #9aa2af;
      box-shadow: 0 0 0 1px rgba(192,192,192,0.4);
    }

    .generated-list {
      border-radius: var(--radius-md);
      border: 1px solid #222832;
      background: #05070c;
      padding: 6px 5px;
      font-family: "JetBrains Mono", "SF Mono", Menlo, Consolas, monospace;
      font-size: 0.78rem;
      flex: 1;
      overflow-y: auto;
      min-height: 60px;
      max-height: 260px;
    }

    .generated-item {
      padding: 2px 6px;
      border-radius: var(--radius-sm);
      cursor: pointer;
      margin-bottom: 2px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .generated-item:hover {
      background: #161b24;
    }

    .muted {
      color: var(--text-muted);
    }

    hr {
      border: none;
      border-top: 1px solid #1a2028;
      margin: 6px 0;
    }

    .section-title {
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: 0.8rem;
      color: var(--accent-soft);
      margin-bottom: 4px;
      gap: 6px;
    }

    .section-title span {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .token-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.78rem;
      margin-top: 2px;
    }

    .token-table th,
    .token-table td {
      border: 1px solid #232a33;
      padding: 4px 6px;
      vertical-align: top;
    }

    .token-table th {
      background: #0b1017;
      color: var(--accent-soft);
      font-weight: 500;
      text-align: left;
    }

    .token-table td {
      background: #05070c;
    }

    .token-table select {
      width: 100%;
      font-size: 0.78rem;
      padding: 3px 6px;
      border-radius: var(--radius-sm);
    }

    .adv-edit-toggle {
      margin-left: auto;
    }

    .adv-tab-bar {
      display: inline-flex;
      border-radius: 999px;
      border: 1px solid #2d3440;
      overflow: hidden;
      margin-bottom: 4px;
      background: #05070c;
    }

    .adv-tab {
      font-size: 0.76rem;
      padding: 4px 10px;
      border: none;
      background: transparent;
      color: var(--text-muted);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .adv-tab.active {
      background: #181f2b;
      color: var(--accent-strong);
    }

    .adv-tab:hover {
      background: #10141d;
    }

    #advEditSection {
      border-radius: var(--radius-md);
      border: 1px solid #232a33;
      background: #05070c;
      padding: 6px;
      margin-top: 4px;
      max-height: 260px;
      overflow-y: auto;
    }

    #advEditSection .row {
      margin-bottom: 4px;
    }

    #advEditSection textarea {
      min-height: 60px;
    }

    /* Advanced token search + chips */
    .adv-token-advanced {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .adv-selected-chips {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      min-height: 22px;
    }

    .adv-chip {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid #3a414d;
      background: #10151f;
      font-size: 0.75rem;
      white-space: nowrap;
    }

    .adv-chip-remove {
      border: none;
      background: transparent;
      color: var(--text-muted);
      font-size: 0.8rem;
      cursor: pointer;
      padding: 0 2px;
    }

    .adv-chip-remove:hover {
      color: var(--danger);
    }

    .adv-search-input {
      font-size: 0.75rem;
      padding: 3px 6px;
    }

    .adv-search-results {
      font-size: 0.75rem;
      max-height: 110px;
      overflow-y: auto;
    }

    .adv-search-item {
      padding: 2px 4px;
      border-radius: 4px;
      cursor: pointer;
    }

    .adv-search-item:hover {
      background: #161b24;
      color: var(--accent-strong);
    }

    /* Toolbox (text cleaner) in sidebar */
    .toolbox {
      border-radius: var(--radius-md);
      border: 1px solid #232a33;
      background: #05070c;
      padding: 6px 8px;
      font-size: 0.78rem;
    }

    .toolbox-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
      gap: 6px;
    }

    .toolbox-title {
      font-size: 0.8rem;
      color: var(--accent-soft);
    }

    .toolbox-body {
      margin-top: 4px;
    }

    .toolbox-row {
      display: grid;
      grid-template-columns: 1fr;
      gap: 4px;
      margin-top: 4px;
    }

    .toolbox-col textarea {
      min-height: 60px;
      font-size: 0.78rem;
    }

    .danger {
      color: var(--danger) !important;
    }

    .generator-create-box {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.78);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 999;
    }

    .generator-create-inner {
      width: 520px;
      max-width: 95vw;
      background: #05070c;
      border-radius: var(--radius-lg);
      border: 1px solid #2b323e;
      box-shadow: var(--shadow-soft);
      padding: 10px 12px;
      font-size: 0.8rem;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .generator-create-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
      gap: 6px;
    }

    .generator-create-title {
      font-size: 0.9rem;
      color: var(--accent-strong);
    }

    .generator-create-body {
      max-height: 60vh;
      overflow-y: auto;
      padding-right: 2px;
    }

    .items-expanded {
      max-height: 260px;
      min-height: 160px;
    }

    @media (max-width: 960px) {
      .layout-main {
        grid-template-columns: minmax(0, 1fr);
        grid-template-rows: auto auto;
      }
      aside.sidebar {
        order: 1;
      }
      section.main-panel {
        order: 2;
      }
      .toolbox-row {
        grid-template-columns: 1fr;
      }
    }

    code {
      font-family: "JetBrains Mono", "SF Mono", Menlo, Consolas, monospace;
      font-size: 0.75rem;
      background: rgba(255,255,255,0.02);
      border-radius: 4px;
      padding: 0 3px;
    }
  </style>
</head>
<body>
  <div class="app-shell">
    <header class="app-header">
      <div class="header-left">
        <div class="app-title">Vrahune Toolbox</div>
        <div class="app-subtitle">
          Local-only generators, lexicons, and templates for your world –
          everything lives in your browser until you export it.
        </div>
      </div>
      <div class="header-right">
        <span class="badge">Offline · Local Storage</span>
        <button id="downloadDbBtn" class="btn-secondary btn-small" type="button">
          ⬇ Download current database
        </button>
      </div>
    </header>

    <div class="layout-main">
      <!-- LEFT: Generators / Folders + Text Cleaner -->
      <aside class="sidebar">
        <div class="sidebar-header">
          <div class="sidebar-header-row">
            <div>
              <div class="sidebar-title">Generators & Lexicons</div>
              <div class="sidebar-subtitle">Click a generator to use it · folders for organization</div>
            </div>
            <button id="addGeneratorBtn" class="btn-primary btn-small" type="button">
              ＋ New
            </button>
          </div>
          <input
            id="generatorSearchInput"
            class="search-input"
            type="text"
            placeholder="Search generators..."
          />
        </div>

        <div id="generatorNav" class="nav-scroll"></div>

        <!-- Text Cleaner toolbox now in sidebar bottom -->
        <div class="sidebar-bottom-tools">
          <div class="toolbox">
            <div class="toolbox-header">
              <div class="toolbox-title">
                Text Cleaner • list formatting helper
              </div>
              <button id="toggleTextCleanerBtn" class="btn-secondary btn-small" type="button">
                Hide
              </button>
            </div>
            <div id="textCleanerBody" class="toolbox-body">
              <div class="muted">
                Paste messy, numbered or multi-column text (e.g. <code>4 Arrogant 54 Logical</code>) below,
                click <b>Clean text</b>, then copy the cleaned list for your generators.
              </div>
              <div class="toolbox-row">
                <div class="toolbox-col">
                  <label for="cleanInput">Raw text</label>
                  <textarea id="cleanInput" placeholder="4 Arrogant 54 Logical&#10;5 Blunt 55 Love-struck&#10;..."></textarea>
                </div>
                <div class="toolbox-col">
                  <label for="cleanOutput">Cleaned · one item per line</label>
                  <textarea id="cleanOutput" readonly></textarea>
                </div>
              </div>
              <div class="row" style="margin-top:4px;">
                <button id="cleanRunBtn" class="btn-primary btn-small" type="button">
                  Clean text
                </button>
                <button id="cleanCopyBtn" class="btn-secondary btn-small" type="button">
                  Copy cleaned text
                </button>
              </div>
            </div>
          </div>
        </div>
      </aside>

      <!-- RIGHT: Active generator -->
      <section class="main-panel">
        <div id="copyMessage">Click any generated item or lexicon entry to copy.</div>

        <div class="generator-panel-wrapper">
          <div id="activeGeneratorLabel">No generator selected</div>
          <div id="generatorPanel">
            <div class="muted">Choose a generator from the left, or click ＋ to create one.</div>
          </div>
        </div>
      </section>
    </div>
  </div>

  <!-- Generator create / edit modal -->
  <div id="generatorCreateBox" class="generator-create-box">
    <div class="generator-create-inner">
      <div class="generator-create-header">
        <div class="generator-create-title">Create / Edit Generator</div>
        <button id="cancelGeneratorBtn" class="btn-secondary btn-small" type="button">
          ✕ Close
        </button>
      </div>
      <div id="generatorCreateMessage" class="muted"></div>
      <div class="generator-create-body">
        <div class="row">
          <div class="col">
            <label for="genNameInput">Generator name</label>
            <input id="genNameInput" type="text" placeholder="Elf Names, NPC Traits, Valathi Lexicon..." />
          </div>
          <div class="col">
            <label for="genFolderSelect">Folder</label>
            <select id="genFolderSelect"></select>
            <input
              id="genFolderNewInput"
              type="text"
              placeholder="New folder name"
              style="margin-top:4px; display:none;"
            />
          </div>
          <div class="col">
            <label for="genTypeInput">Type</label>
            <select id="genTypeInput">
              <option value="list">List (simple pool of items)</option>
              <option value="lexicon">Lexicon (english = valathi)</option>
              <option value="advanced">Advanced (patterns & tokens)</option>
            </select>
          </div>
        </div>

        <div id="genItemsRow" class="row">
          <div class="col">
            <label for="genItemsInput">Items / entries</label>
            <textarea
              id="genItemsInput"
              placeholder="For list: one item per line.&#10;For lexicon: english = valathi, one per line."
            ></textarea>
          </div>
        </div>
      </div>
      <div class="row" style="margin-top:6px; justify-content:space-between;">
        <div class="col">
          <button id="expandItemsBtn" class="btn-secondary btn-small" type="button">
            Expand list editor
          </button>
        </div>
        <div class="col" style="text-align:right;">
          <button id="saveGeneratorBtn" class="btn-primary btn-small" type="button">
            Save generator
          </button>
        </div>
      </div>
    </div>
  </div>

  <script>
    const GEN_STORAGE_KEY = "vrahuneGeneratorsV4";
    const FOLDER_STATE_KEY = "vrahuneFolderStateV1";

    let activeGenerator = null;
    let editingGeneratorId = null;
    let itemsExpanded = false;
    let folderState = {};
    let generatorSearchTerm = "";

    const valathiLexiconSeed = [
      { english: "high, noble, elevated, bright", valathi: "val" },
      { english: "forest, wooded land", valathi: "’ath" },
      { english: "land, domain", valathi: "anna" },
      { english: "seat, city, foundation", valathi: "dor" },
      { english: "stone, mountain, cliff", valathi: "vor" },
      { english: "water, lake", valathi: "mir" },
      { english: "river, flowing path", valathi: "len" },
      { english: "wind, air current", valathi: "vrae" },
      { english: "star, light in the dark", valathi: "sel" },
      { english: "sea, great water", valathi: "thal" },
      { english: "north, cold lands", valathi: "nor" },
      { english: "dusk, evening star", valathi: "ves" },
      { english: "guardian, warden", valathi: "vel" },
      { english: "song, art, beautiful craft", valathi: "rin" },
      { english: "lore, deep knowledge", valathi: "ith" },
      { english: "peace, calm", valathi: "ser" },
      { english: "flame, passion, drive", valathi: "nar" },
      { english: "life, breath, vitality", valathi: "laen" },
      { english: "hidden, secret, veiled", valathi: "vyn" },
      { english: "world, the continent", valathi: "Vrahune" },
      { english: "noble-forest land (realm)", valathi: "Val’athanna" },
      { english: "high seat, noble city", valathi: "Valdora" }
    ];

    function rand(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }

    function showCopyMessage(text) {
      const msg = document.getElementById("copyMessage");
      msg.textContent = `Copied: "${text}"`;
      setTimeout(() => {
        msg.textContent = "Click any generated item or lexicon entry to copy.";
      }, 2500);
    }

    function handleCopyClick(event) {
      const target = event.target;
      if (!target.classList.contains("generated-item")) return;
      const text = target.textContent.trim();
      if (!text) return;
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(text)
          .then(() => showCopyMessage(text))
          .catch(() => showCopyMessage(text));
      } else {
        showCopyMessage(text);
      }
    }

    function parseGeneratorItems(rawText) {
      if (!rawText) return { items: [], duplicates: 0 };
      const lines = rawText.split(/\r?\n/);
      const set = new Set();
      const items = [];
      let total = 0;

      for (const line of lines) {
        const t = line.trim();
        if (!t) continue;
        total++;
        const key = t.toLowerCase();
        if (!set.has(key)) {
          set.add(key);
          items.push(t);
        }
      }
      const duplicates = Math.max(0, total - items.length);
      return { items, duplicates };
    }

    function parseLexiconText(rawText) {
      if (!rawText) return { items: [], duplicates: 0 };
      const lines = rawText.split(/\r?\n/);
      const map = new Map();
      let total = 0;

      for (const line of lines) {
        const t = line.trim();
        if (!t) continue;
        total++;
        let english = "";
        let valathi = "";

        const eqIdx = t.indexOf("=");
        const dashIdx = (eqIdx === -1) ? t.indexOf("-") : -1;

        if (eqIdx !== -1) {
          english = t.slice(0, eqIdx).trim();
          valathi = t.slice(eqIdx + 1).trim();
        } else if (dashIdx !== -1) {
          english = t.slice(0, dashIdx).trim();
          valathi = t.slice(dashIdx + 1).trim();
        } else {
          english = t;
          valathi = t;
        }

        if (!english || !valathi) continue;
        const key = `${english.toLowerCase()}|${valathi.toLowerCase()}`;
        if (!map.has(key)) {
          map.set(key, { english, valathi });
        }
      }

      const items = Array.from(map.values());
      const duplicates = Math.max(0, total - items.length);
      return { items, duplicates };
    }

    function mergeLexiconEntries(existing, incoming) {
      const map = new Map();
      if (Array.isArray(existing)) {
        for (const e of existing) {
          if (!e || !e.english || !e.valathi) continue;
          const key = `${String(e.english).toLowerCase()}|${String(e.valathi).toLowerCase()}`;
          map.set(key, { english: e.english, valathi: e.valathi });
        }
      }
      if (Array.isArray(incoming)) {
        for (const e of incoming) {
          if (!e || !e.english || !e.valathi) continue;
          const key = `${String(e.english).toLowerCase()}|${String(e.valathi).toLowerCase()}`;
          map.set(key, { english: e.english, valathi: e.valathi });
        }
      }
      return Array.from(map.values());
    }

    function extractTokensFromPatterns(patterns) {
      const tokenSet = new Set();
      const tokenRegex = /\{([^}]+)\}/g;
      for (const p of patterns) {
        let m;
        while ((m = tokenRegex.exec(p)) !== null) {
          const token = m[1].trim();
          if (token) tokenSet.add(token);
        }
      }
      return Array.from(tokenSet);
    }

    function cleanTextForGenerator(raw) {
      if (!raw) return "";

      let replaced = raw.replace(/\r\n/g, "\n");

      replaced = replaced.replace(/(^|\s)(\d+)(?=[\.\)]?\s*[A-Za-z])/g, "\n$2");

      const lines = replaced.split(/\n+/);
      const cleaned = [];

      for (let line of lines) {
        let t = line.trim();
        if (!t) continue;

        t = t.replace(/^[\-\*\u2022]+\s*/, "");
        t = t.replace(/^\d+[\.\)]?\s*/, "");
        t = t.replace(/\s{2,}/g, " ");
        t = t.trim().replace(/[,\s]+$/, "").trim();

        if (t) cleaned.push(t);
      }

      return cleaned.join("\n");
    }

    function loadFolderState() {
      try {
        const raw = window.localStorage.getItem(FOLDER_STATE_KEY);
        if (!raw) return {};
        const parsed = JSON.parse(raw);
        return parsed && typeof parsed === "object" ? parsed : {};
      } catch {
        return {};
      }
    }

    function saveFolderState() {
      try {
        window.localStorage.setItem(FOLDER_STATE_KEY, JSON.stringify(folderState));
      } catch {}
    }

    function seedInitialGenerators() {
      const elfStartId = "seed-elf-starts";
      const elfMiddleId = "seed-elf-middles";
      const elfEndSoftId = "seed-elf-ends-soft";
      const elfEndSharpId = "seed-elf-ends-sharp";
      const bookAdjId = "seed-book-adj";
      const bookNounId = "seed-book-noun";
      const bookPlaceId = "seed-book-place";

      return [
        {
          id: elfStartId,
          folder: "Names",
          name: "Elf Name Starts",
          type: "list",
          items: [
            "Val","Ves","Vor","Vrae","Sel","Thal","Mir","Nor","Lae","Vel","Vyn","Maer",
            "Ael","Ny","Syl","Cae","Ari","Eli","Var","Lor","Sael","Cal","Ser","Ty","Vael","Oryn"
          ]
        },
        {
          id: elfMiddleId,
          folder: "Names",
          name: "Elf Name Middles",
          type: "list",
          items: [
            "a","e","i","o","la","le","li","ra","re","ri","sa","se","thal","lyn","rin"
          ]
        },
        {
          id: elfEndSoftId,
          folder: "Names",
          name: "Elf Name Ends (Soft)",
          type: "list",
          items: [
            "a","ae","ira","iel","essa","yn","yne","ara","ina"
          ]
        },
        {
          id: elfEndSharpId,
          folder: "Names",
          name: "Elf Name Ends (Sharp)",
          type: "list",
          items: [
            "as","ix","or","eth","is","ar","ax","an","orix"
          ]
        },
        {
          id: bookAdjId,
          folder: "Names",
          name: "Book Adjectives",
          type: "list",
          items: [
            "Silent","Forgotten","Gilded","Broken","Crimson","Twilight","Shattered",
            "Hidden","Last","Bound","Whispering","Silver","Onyx","Verdant","Burning","Veiled"
          ]
        },
        {
          id: bookNounId,
          folder: "Names",
          name: "Book Nouns",
          type: "list",
          items: [
            "Throne","Forest","Empire","Oath","Crown","River","Sea","Spire",
            "Song","Shadow","Light","Wolf","King","Queen","Chronicle","Blade","Storm","Gate"
          ]
        },
        {
          id: bookPlaceId,
          folder: "Names",
          name: "Book Places (Vrahune)",
          type: "list",
          items: [
            "Vrahune","Val’athanna","Valdora","Fallen Spears","Frostclaw Wilds",
            "Verdant Veil","Onyx Empire","Raven Fields","New Hope Frontier"
          ]
        },
        {
          id: "seed-elf-names-template",
          folder: "Names",
          name: "Elf Names (Template)",
          type: "advanced",
          items: {
            patterns: [
              "{Start}{EndSoft}",
              "{Start}{Middle}{EndSoft}",
              "{Start}{EndSharp}",
              "{Start}{Middle}{EndSharp}"
            ],
            tokenMap: {
              Start: elfStartId,
              Middle: elfMiddleId,
              EndSoft: elfEndSoftId,
              EndSharp: elfEndSharpId
            },
            multiTokenMap: {}
          }
        },
        {
          id: "seed-book-titles-template",
          folder: "Names",
          name: "Book Titles (Template)",
          type: "advanced",
          items: {
            patterns: [
              "The {Adj} {Noun}",
              "The {Adj} {Noun} of {Place}",
              "{Noun} of {Place}",
              "{Place}: The {Adj} {Noun}"
            ],
            tokenMap: {
              Adj: bookAdjId,
              Noun: bookNounId,
              Place: bookPlaceId
            },
            multiTokenMap: {}
          }
        },
        {
          id: "gen-lex-valathi",
          folder: "Lexicons",
          name: "Valathi Lexicon",
          type: "lexicon",
          items: valathiLexiconSeed
        }
      ];
    }

    function loadGenerators() {
      try {
        const raw = window.localStorage.getItem(GEN_STORAGE_KEY);
        if (!raw) return [];
        const parsed = JSON.parse(raw);
        if (!Array.isArray(parsed)) return [];
        return parsed.map(g => {
          const type = g.type || "list";
          let items = g.items;
          if (type === "list") {
            items = Array.isArray(items) ? items : [];
          } else if (type === "lexicon") {
            items = Array.isArray(items) ? items : [];
          } else if (type === "advanced") {
            if (!items || typeof items !== "object") {
              items = {};
            }
            items.patterns = Array.isArray(items.patterns) ? items.patterns : [];
            items.tokenMap = items.tokenMap && typeof items.tokenMap === "object" ? items.tokenMap : {};
            items.multiTokenMap = items.multiTokenMap && typeof items.multiTokenMap === "object" ? items.multiTokenMap : {};
          }
          return { ...g, type, items };
        });
      } catch {
        return [];
      }
    }

    function saveGenerators(list) {
      try {
        window.localStorage.setItem(GEN_STORAGE_KEY, JSON.stringify(list));
      } catch {}
    }

    function populateFolderSelect(selectedFolder) {
      const select = document.getElementById("genFolderSelect");
      if (!select) return;

      const gens = loadGenerators();
      const folderSet = new Set();

      gens.forEach(g => {
        const f = g.folder || "General";
        folderSet.add(f);
      });

      const folderNames = Array.from(folderSet).sort((a, b) => a.localeCompare(b));

      if (selectedFolder && selectedFolder !== "__new__" && !folderSet.has(selectedFolder)) {
        folderNames.push(selectedFolder);
      }

      select.innerHTML = "";

      folderNames.forEach(f => {
        const opt = document.createElement("option");
        opt.value = f;
        opt.textContent = f;
        select.appendChild(opt);
      });

      const optNew = document.createElement("option");
      optNew.value = "__new__";
      optNew.textContent = "+ New folder…";
      select.appendChild(optNew);

      if (selectedFolder && selectedFolder !== "__new__" && folderNames.includes(selectedFolder)) {
        select.value = selectedFolder;
      } else if (folderNames.length > 0) {
        select.value = folderNames[0];
      } else {
        select.value = "__new__";
      }

      handleFolderSelectChange();
    }

    function handleFolderSelectChange() {
      const select = document.getElementById("genFolderSelect");
      const newInput = document.getElementById("genFolderNewInput");
      if (!select || !newInput) return;

      if (select.value === "__new__") {
        newInput.style.display = "block";
      } else {
        newInput.style.display = "none";
        newInput.value = "";
      }
    }

    function renderGeneratorNav() {
      const nav = document.getElementById("generatorNav");
      nav.innerHTML = "";

      const gens = loadGenerators();
      const folderMap = {};

      gens.forEach(gen => {
        const folder = gen.folder || "General";
        if (!folderMap[folder]) folderMap[folder] = [];
        folderMap[folder].push(gen);
      });

      const folderNames = Object.keys(folderMap).sort((a, b) => a.localeCompare(b));

      if (!folderNames.length) {
        nav.innerHTML = `<div class="muted" style="font-size:0.8rem; padding:4px 4px 8px;">No generators yet. Click ＋ to create one.</div>`;
        return;
      }

      const q = (generatorSearchTerm || "").trim().toLowerCase();
      let hasAnyMatch = false;

      folderNames.forEach(folder => {
        let gensInFolder = folderMap[folder].slice().sort((a,b) => a.name.localeCompare(b.name));

        if (q) {
          gensInFolder = gensInFolder.filter(g =>
            String(g.name || "").toLowerCase().includes(q)
          );
        }

        if (!gensInFolder.length) return;

        hasAnyMatch = true;
        const count = gensInFolder.length;
        const collapsed = folderState[folder] && folderState[folder].collapsed;

        const heading = document.createElement("div");
        heading.className = "nav-folder-heading";
        heading.dataset.folder = folder;
        heading.innerHTML = `
          <span class="folder-toggle">
            <span class="folder-arrow">${collapsed ? "▸" : "▾"}</span>
            <span class="folder-label">${folder}</span>
            <span class="folder-badge">(${count})</span>
          </span>
          <button class="folder-rename-btn btn-secondary btn-small" type="button">✎</button>
        `;
        nav.appendChild(heading);

        if (!collapsed) {
          gensInFolder.forEach(gen => {
            const item = document.createElement("div");
            item.className = "nav-generator";
            item.dataset.id = gen.id;

            const isActive = activeGenerator && activeGenerator.id === gen.id;
            if (isActive) item.classList.add("active");

            item.innerHTML = `<span class="name">${gen.name}</span>`;
            nav.appendChild(item);
          });
        }
      });

      if (!hasAnyMatch && q) {
        nav.innerHTML = `<div class="muted" style="font-size:0.8rem; padding:4px 4px 8px;">No generators match “${generatorSearchTerm}”.</div>`;
      }
    }

    function renderActiveGeneratorPanel() {
      const label = document.getElementById("activeGeneratorLabel");
      const panel = document.getElementById("generatorPanel");
      panel.innerHTML = "";
      panel.removeEventListener("click", handleCopyClick);

      if (!activeGenerator) {
        label.textContent = "No generator selected";
        panel.innerHTML = `<div class="muted">Choose a generator from the left, or click ＋ to create one.</div>`;
        return;
      }

      const gens = loadGenerators();
      const gen = gens.find(g => g.id === activeGenerator.id);
      if (!gen) {
        label.textContent = "Generator not found";
        panel.innerHTML = `<div class="muted">This generator no longer exists. Choose another one.</div>`;
        return;
      }

      label.textContent = `${gen.name} (${gen.folder || "General"})`;

      if (gen.type === "list") {
        panel.innerHTML = `
          <div class="generator-title-main">
            ${gen.name}
          </div>
          <div class="muted" style="margin-bottom:8px;">
            Folder: ${gen.folder || "General"} · ${gen.items.length} items in pool.
          </div>
          <div class="row">
            <div class="col">
              <label for="customCountInput">Count</label>
              <input id="customCountInput" type="number" min="1" max="50" value="10">
            </div>
            <div class="col">
              <label>&nbsp;</label>
              <button id="customGenerateBtn" class="btn-primary">Generate</button>
            </div>
          </div>
          <div class="row">
            <button id="customEditBtn" class="btn-secondary btn-small">Edit items</button>
            <button id="customDeleteBtn" class="btn-secondary btn-small">Delete generator</button>
          </div>
          <div id="customResults" class="generated-list"></div>
        `;

        const countInput = panel.querySelector("#customCountInput");
        const genBtn = panel.querySelector("#customGenerateBtn");
        const editBtn = panel.querySelector("#customEditBtn");
        const delBtn  = panel.querySelector("#customDeleteBtn");
        const results = panel.querySelector("#customResults");

        genBtn.addEventListener("click", () => {
          const pool = [...gen.items];
          const count = Math.max(1, Math.min(50, parseInt(countInput.value || "1", 10)));
          results.innerHTML = "";
          const frag = document.createDocumentFragment();
          if (!pool.length) return;
          for (let i = 0; i < count; i++) {
            if (!pool.length) break;
            const idx = Math.floor(Math.random() * pool.length);
            const value = pool.splice(idx, 1)[0];
            const div = document.createElement("div");
            div.className = "generated-item";
            div.textContent = value;
            frag.appendChild(div);
          }
          results.appendChild(frag);
        });

        results.addEventListener("click", handleCopyClick);

        editBtn.addEventListener("click", () => {
          openEditGeneratorBox(gen.id);
        });

        delBtn.addEventListener("click", () => {
          const ok = window.confirm(`Delete generator “${gen.name}” from folder “${gen.folder || "General"}”?`);
          if (!ok) return;
          const newList = gens.filter(g => g.id !== gen.id);
          saveGenerators(newList);
          if (activeGenerator && activeGenerator.id === gen.id) {
            activeGenerator = null;
          }
          renderGeneratorNav();
          renderActiveGeneratorPanel();
        });

        return;
      }

      if (gen.type === "lexicon") {
        panel.innerHTML = `
          <div class="generator-title-main">
            ${gen.name}
          </div>
          <div class="muted" style="margin-bottom:8px;">
            Folder: ${gen.folder || "General"} · ${gen.items.length} lexicon entries.
          </div>

          <div class="row">
            <div class="col">
              <label for="lexMode">Direction</label>
              <select id="lexMode">
                <option value="en-to-va">Common → Valathi</option>
                <option value="va-to-en">Valathi → Common</option>
              </select>
            </div>
            <div class="col">
              <label for="lexQuery">Word</label>
              <input id="lexQuery" type="text" placeholder="Type a word to look up">
            </div>
            <div class="col">
              <label>&nbsp;</label>
              <button id="lexSearchBtn" class="btn-primary">Translate</button>
            </div>
          </div>

          <div id="lexResult" class="generated-list"></div>

          <hr>

          <div class="section-title">
            <span>Manage entries</span>
          </div>
          <div class="row">
            <div class="col">
              <label for="lexiconAddInput">Add entries (english = valathi)</label>
              <textarea id="lexiconAddInput" placeholder="high = val&#10;forest = ’ath"></textarea>
            </div>
          </div>
          <div class="row">
            <button id="lexAppendBtn" class="btn-secondary btn-small">Append from text</button>
            <button id="lexImportBtn" class="btn-secondary btn-small">Import from JSON/HTML</button>
            <button id="lexDownloadBtn" class="btn-secondary btn-small">Download JSON</button>
            <button id="lexOpenEditBtn" class="btn-secondary btn-small">Edit as raw</button>
            <button id="lexDeleteBtn" class="btn-secondary btn-small">Delete generator</button>
          </div>
          <input type="file" id="lexFileInput" accept=".json,.txt,.html" style="display:none;">
          <div id="lexMessage" class="muted" style="margin-top:4px;"></div>

          <div class="section-title" style="margin-top:10px;">
            <span>All entries</span>
            <span class="muted" style="font-size:0.75rem;">Click to copy "english = valathi"</span>
          </div>
          <div id="lexAllEntries" class="generated-list"></div>
        `;

        const lexMode = panel.querySelector("#lexMode");
        const lexQuery = panel.querySelector("#lexQuery");
        const lexSearchBtn = panel.querySelector("#lexSearchBtn");
        const lexResult = panel.querySelector("#lexResult");
        const lexAllEntries = panel.querySelector("#lexAllEntries");
        const lexAddInput = panel.querySelector("#lexiconAddInput");
        const lexAppendBtn = panel.querySelector("#lexAppendBtn");
        const lexImportBtn = panel.querySelector("#lexImportBtn");
        const lexDownloadBtn = panel.querySelector("#lexDownloadBtn");
        const lexFileInput = panel.querySelector("#lexFileInput");
        const lexMessage = panel.querySelector("#lexMessage");
        const lexOpenEditBtn = panel.querySelector("#lexOpenEditBtn");
        const lexDeleteBtn = panel.querySelector("#lexDeleteBtn");

        function renderAllEntriesList(items) {
          lexAllEntries.innerHTML = "";
          const sorted = [...items].sort((a, b) =>
            String(a.english).localeCompare(String(b.english))
          );
          const frag = document.createDocumentFragment();
          for (const e of sorted) {
            const div = document.createElement("div");
            div.className = "generated-item";
            div.textContent = `${e.english} = ${e.valathi}`;
            frag.appendChild(div);
          }
          lexAllEntries.appendChild(frag);
        }

        function searchLexicon(items, query, mode) {
          const q = query.trim().toLowerCase();
          if (!q) return [];
          if (mode === "en-to-va") {
            return items.filter(e => String(e.english).toLowerCase().includes(q));
          } else {
            return items.filter(e => String(e.valathi).toLowerCase().includes(q));
          }
        }

        function doSearch() {
          const gensCurrent = loadGenerators();
          const g = gensCurrent.find(x => x.id === gen.id);
          if (!g) return;

          const items = Array.isArray(g.items) ? g.items : [];
          const mode = lexMode.value;
          const q = lexQuery.value;
          const matches = searchLexicon(items, q, mode);
          lexResult.innerHTML = "";

          if (!q.trim()) {
            lexResult.innerHTML = `<div class="muted">Type a word and click Translate.</div>`;
            return;
          }

          if (!matches.length) {
            lexResult.innerHTML = `<div class="muted">No entries found for "${q}".</div>`;
            return;
          }

          const frag = document.createDocumentFragment();
          for (const e of matches) {
            const div = document.createElement("div");
            div.className = "generated-item";
            if (mode === "en-to-va") {
              div.textContent = `${e.english} → ${e.valathi}`;
            } else {
              div.textContent = `${e.valathi} → ${e.english}`;
            }
            frag.appendChild(div);
          }
          lexResult.appendChild(frag);
        }

        lexSearchBtn.addEventListener("click", doSearch);
        lexQuery.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            doSearch();
          }
        });

        lexResult.addEventListener("click", handleCopyClick);
        lexAllEntries.addEventListener("click", handleCopyClick);

        lexAppendBtn.addEventListener("click", () => {
          const raw = lexAddInput.value || "";
          if (!raw.trim()) {
            lexMessage.textContent = "No text to append.";
            return;
          }
          const { items: newItems, duplicates } = parseLexiconText(raw);
          if (!newItems.length) {
            lexMessage.textContent = "No valid entries found. Use 'english = valathi'.";
            return;
          }
          const gensCurrent = loadGenerators();
          const idx = gensCurrent.findIndex(x => x.id === gen.id);
          if (idx === -1) return;
          const before = Array.isArray(gensCurrent[idx].items) ? gensCurrent[idx].items : [];
          const merged = mergeLexiconEntries(before, newItems);
          const added = merged.length - before.length;

          gensCurrent[idx].items = merged;
          saveGenerators(gensCurrent);
          lexAddInput.value = "";

          lexMessage.textContent =
            `Appended ${added} entries. ${duplicates > 0 ? duplicates + " duplicate lines removed." : "No duplicates in input."}`;
          renderAllEntriesList(merged);
        });

        lexImportBtn.addEventListener("click", () => {
          lexFileInput.value = "";
          lexFileInput.click();
        });

        lexFileInput.addEventListener("change", (e) => {
          const file = e.target.files && e.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = (ev) => {
            const text = ev.target.result;
            let imported = [];

            try {
              const parsed = JSON.parse(text);
              if (Array.isArray(parsed)) {
                for (const item of parsed) {
                  if (!item) continue;
                  if (typeof item === "string") {
                    const { items } = parseLexiconText(item);
                    imported = imported.concat(items);
                  } else if (typeof item === "object") {
                    const english = item.english || item.en || item.word || item.key || "";
                    const valathi = item.valathi || item.va || item.value || "";
                    if (english && valathi) {
                      imported.push({ english, valathi });
                    }
                  }
                }
              } else if (typeof parsed === "object") {
                for (const key in parsed) {
                  if (!Object.prototype.hasOwnProperty.call(parsed, key)) continue;
                  const english = key;
                  const valathi = parsed[key];
                  if (english && valathi) {
                    imported.push({ english, valathi });
                  }
                }
              }
            } catch {
              const { items } = parseLexiconText(text);
              imported = imported.concat(items);
            }

            if (!imported.length) {
              lexMessage.textContent = "No valid entries found in file.";
              return;
            }

            const gensCurrent = loadGenerators();
            const idx = gensCurrent.findIndex(x => x.id === gen.id);
            if (idx === -1) return;

            const before = Array.isArray(gensCurrent[idx].items) ? gensCurrent[idx].items : [];
            const merged = mergeLexiconEntries(before, imported);
            const added = merged.length - before.length;

            gensCurrent[idx].items = merged;
            saveGenerators(gensCurrent);
            lexMessage.textContent = `Imported ${added} new entries from file.`;
            renderAllEntriesList(merged);
          };
          reader.readAsText(file);
        });

        lexDownloadBtn.addEventListener("click", () => {
          const gensCurrent = loadGenerators();
          const g = gensCurrent.find(x => x.id === gen.id);
          if (!g) return;
          const dataStr = JSON.stringify(g.items || [], null, 2);
          const blob = new Blob([dataStr], { type: "application/json" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `${g.name.replace(/\s+/g, "_")}.json`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        });

        lexOpenEditBtn.addEventListener("click", () => {
          openEditGeneratorBox(gen.id);
        });

        lexDeleteBtn.addEventListener("click", () => {
          const ok = window.confirm(`Delete generator “${gen.name}” from folder “${gen.folder || "General"}”?`);
          if (!ok) return;
          const newList = gens.filter(g => g.id !== gen.id);
          saveGenerators(newList);
          if (activeGenerator && activeGenerator.id === gen.id) {
            activeGenerator = null;
          }
          renderGeneratorNav();
          renderActiveGeneratorPanel();
        });

        renderAllEntriesList(gen.items || []);
        return;
      }

      if (gen.type === "advanced") {
        const items = gen.items || {};
        const patterns = Array.isArray(items.patterns) ? items.patterns : [];
        const simpleTokenMap = items.tokenMap && typeof items.tokenMap === "object" ? items.tokenMap : {};
        const multiTokenMap = items.multiTokenMap && typeof items.multiTokenMap === "object" ? items.multiTokenMap : {};
        const patternsText = patterns.join("\n");
        const allTokens = extractTokensFromPatterns(patterns);

        panel.innerHTML = `
          <div class="generator-title-main">
            ${gen.name}
          </div>
          <div class="muted" style="margin-bottom:8px;">
            Advanced generator that stitches together outputs from your other generators using <code>{Tokens}</code>.
            Use <b>Simple</b> for one generator per token, or <b>Advanced</b> to let a token pull from multiple generators with search & click.
          </div>

          <div class="row">
            <div class="col">
              <label for="advCountInput">Count</label>
              <input id="advCountInput" type="number" min="1" max="50" value="10">
            </div>
            <div class="col">
              <label>&nbsp;</label>
              <button id="advGenerateBtn" class="btn-primary">Generate</button>
            </div>
          </div>

          <div id="advResults" class="generated-list"></div>

          <hr>

          <div class="section-title">
            <span>Template & mappings</span>
            <button id="advEditToggleBtn" class="btn-secondary btn-small adv-edit-toggle" type="button">
              Edit template & mappings
            </button>
          </div>
          <div class="muted" style="font-size:0.78rem; margin-bottom:4px;">
            Keep this closed if you just want to generate with the existing setup. Open it to tweak patterns or which generators each <code>{Token}</code> pulls from.
          </div>

          <div id="advEditSection" style="display:none;">
            <div class="row">
              <div class="col">
                <label for="advPatternsInput">Patterns (one per line)</label>
                <textarea id="advPatternsInput" placeholder="{Name} is a {Race} from {Hometown}, known for {Trait}.">${patternsText}</textarea>
              </div>
            </div>

            <div class="section-title" style="margin-top:4px;">
              <span>Token mappings</span>
            </div>
            <div class="muted" style="font-size:0.78rem; margin-bottom:4px;">
              <b>Simple tab:</b> one generator per token. <b>Advanced tab:</b> for each token, search and click to add multiple generators.  
              On use, one of those generators is chosen at random.
            </div>

            <div class="adv-tab-bar">
              <button type="button" class="adv-tab active" data-mode="simple">Simple</button>
              <button type="button" class="adv-tab" data-mode="advanced">Advanced</button>
            </div>

            <div id="advTokensSimpleContainer"></div>
            <div id="advTokensAdvancedContainer" style="display:none; margin-top:4px;"></div>

            <div class="muted" style="font-size:0.75rem; margin-top:4px;">
              <b>Advanced mode tips:</b>  
              • Start typing to search your list generators.  
              • Click a result to add it as a chip.  
              • Click ✕ on a chip to remove it.
            </div>

            <div class="row" style="margin-top:6px;">
              <button id="advSaveBtn" class="btn-primary btn-small">Save template & mappings</button>
              <button id="advDeleteBtn" class="btn-secondary btn-small">Delete generator</button>
            </div>
          </div>
        `;

        const advCountInput = panel.querySelector("#advCountInput");
        const advGenerateBtn = panel.querySelector("#advGenerateBtn");
        const advResults = panel.querySelector("#advResults");
        const advEditToggleBtn = panel.querySelector("#advEditToggleBtn");
        const advEditSection = panel.querySelector("#advEditSection");
        const advPatternsInput = panel.querySelector("#advPatternsInput");
        const advTokensSimpleContainer = panel.querySelector("#advTokensSimpleContainer");
        const advTokensAdvancedContainer = panel.querySelector("#advTokensAdvancedContainer");
        const advSaveBtn = panel.querySelector("#advSaveBtn");
        const advDeleteBtn = panel.querySelector("#advDeleteBtn");
        const advTabs = panel.querySelectorAll(".adv-tab");

        let advMode = "simple";

        function setAdvMode(mode) {
          advMode = mode === "advanced" ? "advanced" : "simple";
          advTabs.forEach(btn => {
            if (btn.dataset.mode === advMode) {
              btn.classList.add("active");
            } else {
              btn.classList.remove("active");
            }
          });
          if (advMode === "simple") {
            advTokensSimpleContainer.style.display = "block";
            advTokensAdvancedContainer.style.display = "none";
          } else {
            advTokensSimpleContainer.style.display = "none";
            advTokensAdvancedContainer.style.display = "block";
          }
        }

        function renderTokenMappingsSimple(tokens, map) {
          if (!tokens.length) {
            advTokensSimpleContainer.innerHTML = `<div class="muted" style="margin-top:4px;">No tokens found yet. Add <code>{Token}</code> placeholders to your patterns above, then save.</div>`;
            return;
          }
          const gensAll = loadGenerators();
          const listGenerators = gensAll.filter(g => g.type === "list");
          const table = document.createElement("table");
          table.className = "token-table";
          table.innerHTML = `
            <thead>
              <tr>
                <th style="width:20%;">Token</th>
                <th>Source generator (list)</th>
              </tr>
            </thead>
            <tbody></tbody>
          `;
          const tbody = table.querySelector("tbody");

          tokens.forEach(token => {
            const tr = document.createElement("tr");
            const optionsHtml = [
              `<option value="">— none —</option>`,
              ...listGenerators.map(g => `<option value="${g.id}">${g.name}</option>`)
            ].join("");
            tr.innerHTML = `
              <td>{${token}}</td>
              <td>
                <select class="adv-token-select" data-token="${token}">
                  ${optionsHtml}
                </select>
              </td>
            `;
            tbody.appendChild(tr);
          });

          advTokensSimpleContainer.innerHTML = "";
          advTokensSimpleContainer.appendChild(table);

          const selects = advTokensSimpleContainer.querySelectorAll(".adv-token-select");
          selects.forEach(sel => {
            const tok = sel.dataset.token;
            const mappedId = map[tok] || "";
            if (mappedId) sel.value = mappedId;
          });
        }

        function refreshAdvancedSelectedChips(wrapper, selectedIds, listGenerators) {
          const chipsContainer = wrapper.querySelector(".adv-selected-chips");
          chipsContainer.innerHTML = "";
          const frag = document.createDocumentFragment();

          selectedIds.forEach(id => {
            const g = listGenerators.find(x => x.id === id);
            if (!g) return;
            const span = document.createElement("span");
            span.className = "adv-chip";
            span.dataset.id = id;
            span.textContent = g.name;
            const btn = document.createElement("button");
            btn.type = "button";
            btn.className = "adv-chip-remove";
            btn.textContent = "✕";
            span.appendChild(btn);
            frag.appendChild(span);
          });

          chipsContainer.appendChild(frag);
        }

        function renderTokenMappingsAdvanced(tokens, map) {
          if (!tokens.length) {
            advTokensAdvancedContainer.innerHTML = `<div class="muted" style="margin-top:4px;">No tokens to configure yet. Once you add <code>{Token}</code> placeholders and save, you can assign multiple generators per token here.</div>`;
            return;
          }
          const gensAll = loadGenerators();
          const listGenerators = gensAll.filter(g => g.type === "list");
          advTokensAdvancedContainer.__listGenerators = listGenerators;

          const table = document.createElement("table");
          table.className = "token-table";
          table.innerHTML = `
            <thead>
              <tr>
                <th style="width:20%;">Token</th>
                <th>Allowed generators (search & click)</th>
              </tr>
            </thead>
            <tbody></tbody>
          `;
          const tbody = table.querySelector("tbody");

          tokens.forEach(token => {
            const tr = document.createElement("tr");
            const tdToken = document.createElement("td");
            tdToken.textContent = `{${token}}`;
            const tdUi = document.createElement("td");

            const wrapper = document.createElement("div");
            wrapper.className = "adv-token-advanced";
            wrapper.dataset.token = token;

            wrapper.innerHTML = `
              <div class="adv-selected-chips"></div>
              <input type="text" class="adv-search-input" placeholder="Search generators...">
              <div class="adv-search-results muted">Type to search your list generators…</div>
            `;

            tdUi.appendChild(wrapper);
            tr.appendChild(tdToken);
            tr.appendChild(tdUi);
            tbody.appendChild(tr);
          });

          advTokensAdvancedContainer.innerHTML = "";
          advTokensAdvancedContainer.appendChild(table);

          // Initialize chips from existing map
          tokens.forEach(token => {
            const wrapper = advTokensAdvancedContainer.querySelector(`.adv-token-advanced[data-token="${token}"]`);
            if (!wrapper) return;
            const selectedIds = Array.isArray(map[token]) ? map[token] : [];
            refreshAdvancedSelectedChips(wrapper, selectedIds, listGenerators);
          });
        }

        function handleAdvancedSearchInput(e) {
          const input = e.target;
          if (!input.classList.contains("adv-search-input")) return;
          const wrapper = input.closest(".adv-token-advanced");
          if (!wrapper) return;

          const listGenerators = advTokensAdvancedContainer.__listGenerators || [];
          const resultsDiv = wrapper.querySelector(".adv-search-results");
          const q = (input.value || "").trim().toLowerCase();

          const selectedIds = Array.from(wrapper.querySelectorAll(".adv-chip"))
            .map(chip => chip.dataset.id);

          if (!q) {
            resultsDiv.textContent = "Type to search your list generators…";
            return;
          }

          const matches = listGenerators
            .filter(g => g.name.toLowerCase().includes(q) && !selectedIds.includes(g.id))
            .slice(0, 10);

          if (!matches.length) {
            resultsDiv.textContent = "No matches.";
            return;
          }

          resultsDiv.innerHTML = "";
          const frag = document.createDocumentFragment();
          matches.forEach(g => {
            const div = document.createElement("div");
            div.className = "adv-search-item";
            div.dataset.id = g.id;
            div.textContent = g.name;
            frag.appendChild(div);
          });
          resultsDiv.appendChild(frag);
        }

        function handleAdvancedClick(e) {
          const listGenerators = advTokensAdvancedContainer.__listGenerators || [];

          const removeBtn = e.target.closest(".adv-chip-remove");
          if (removeBtn) {
            const chip = removeBtn.closest(".adv-chip");
            const wrapper = removeBtn.closest(".adv-token-advanced");
            if (!chip || !wrapper) return;
            chip.remove();
            return;
          }

          const searchItem = e.target.closest(".adv-search-item");
          if (searchItem) {
            const wrapper = searchItem.closest(".adv-token-advanced");
            if (!wrapper) return;
            const id = searchItem.dataset.id;
            const selectedIds = Array.from(wrapper.querySelectorAll(".adv-chip"))
              .map(chip => chip.dataset.id);
            if (!selectedIds.includes(id)) {
              selectedIds.push(id);
            }
            refreshAdvancedSelectedChips(wrapper, selectedIds, listGenerators);

            const input = wrapper.querySelector(".adv-search-input");
            const resultsDiv = wrapper.querySelector(".adv-search-results");
            if (input) input.value = "";
            if (resultsDiv) resultsDiv.textContent = "Type to search your list generators…";
            return;
          }
        }

        renderTokenMappingsSimple(allTokens, simpleTokenMap);
        renderTokenMappingsAdvanced(allTokens, multiTokenMap);
        setAdvMode("simple");

        advEditToggleBtn.addEventListener("click", () => {
          const isHidden = advEditSection.style.display === "none";
          advEditSection.style.display = isHidden ? "block" : "none";
          advEditToggleBtn.textContent = isHidden ? "Hide template & mappings" : "Edit template & mappings";
        });

        advTabs.forEach(btn => {
          btn.addEventListener("click", () => {
            setAdvMode(btn.dataset.mode);
          });
        });

        advTokensAdvancedContainer.addEventListener("input", handleAdvancedSearchInput);
        advTokensAdvancedContainer.addEventListener("click", handleAdvancedClick);

        advSaveBtn.addEventListener("click", () => {
          const rawPatterns = (advPatternsInput.value || "")
            .split(/\r?\n/)
            .map(s => s.trim())
            .filter(Boolean);
          const newTokens = extractTokensFromPatterns(rawPatterns);

          const gensCurrent = loadGenerators();
          const idx = gensCurrent.findIndex(x => x.id === gen.id);
          if (idx === -1) return;

          const simpleMapNew = {};
          const simpleSelects = advTokensSimpleContainer.querySelectorAll(".adv-token-select");
          simpleSelects.forEach(sel => {
            const tok = sel.dataset.token;
            const val = sel.value || "";
            if (tok && val) {
              simpleMapNew[tok] = val;
            }
          });

          const multiMapNew = {};
          const wrappers = advTokensAdvancedContainer.querySelectorAll(".adv-token-advanced");
          wrappers.forEach(wrapper => {
            const tok = wrapper.dataset.token;
            const chips = wrapper.querySelectorAll(".adv-chip");
            const ids = Array.from(chips).map(chip => chip.dataset.id).filter(Boolean);
            if (tok && ids.length) {
              multiMapNew[tok] = ids;
            }
          });

          gensCurrent[idx].items = gensCurrent[idx].items || {};
          gensCurrent[idx].items.patterns = rawPatterns;
          gensCurrent[idx].items.tokenMap = simpleMapNew;
          gensCurrent[idx].items.multiTokenMap = multiMapNew;

          saveGenerators(gensCurrent);

          renderTokenMappingsSimple(newTokens, simpleMapNew);
          renderTokenMappingsAdvanced(newTokens, multiMapNew);

          const msg = document.getElementById("copyMessage");
          msg.textContent = `Saved ${rawPatterns.length} pattern(s), ${Object.keys(simpleMapNew).length} simple mapping(s), ${Object.keys(multiMapNew).length} advanced mapping(s).`;
          setTimeout(() => {
            msg.textContent = "Click any generated item or lexicon entry to copy.";
          }, 2500);
        });

        advDeleteBtn.addEventListener("click", () => {
          const gensCurrent = loadGenerators();
          const ok = window.confirm(`Delete generator “${gen.name}” from folder “${gen.folder || "General"}”?`);
          if (!ok) return;
          const newList = gensCurrent.filter(g => g.id !== gen.id);
          saveGenerators(newList);
          if (activeGenerator && activeGenerator.id === gen.id) {
            activeGenerator = null;
          }
          renderGeneratorNav();
          renderActiveGeneratorPanel();
        });

        advGenerateBtn.addEventListener("click", () => {
          const gensLatest = loadGenerators();
          const gCurrent = gensLatest.find(x => x.id === gen.id);
          if (!gCurrent || gCurrent.type !== "advanced") return;
          const advItems = gCurrent.items || {};
          const patternsNow = Array.isArray(advItems.patterns) ? advItems.patterns : [];
          const simpleMapNow = advItems.tokenMap && typeof advItems.tokenMap === "object" ? advItems.tokenMap : {};
          const multiMapNow = advItems.multiTokenMap && typeof advItems.multiTokenMap === "object" ? advItems.multiTokenMap : {};

          advResults.innerHTML = "";

          if (!patternsNow.length) {
            advResults.innerHTML = `<div class="muted">No patterns defined yet. Click “Edit template & mappings” and add at least one pattern.</div>`;
            return;
          }

          const count = Math.max(1, Math.min(50, parseInt(advCountInput.value || "1", 10)));
          const genById = {};
          gensLatest.forEach(x => { genById[x.id] = x; });

          const frag = document.createDocumentFragment();

          for (let i = 0; i < count; i++) {
            const pattern = rand(patternsNow);
            const tokensInPattern = extractTokensFromPatterns([pattern]);
            let result = pattern;

            tokensInPattern.forEach(tok => {
              let chosenGenId = null;
              if (advMode === "advanced") {
                const listIds = multiMapNow[tok];
                if (Array.isArray(listIds) && listIds.length) {
                  chosenGenId = rand(listIds);
                } else if (simpleMapNow[tok]) {
                  chosenGenId = simpleMapNow[tok];
                }
              } else {
                chosenGenId = simpleMapNow[tok];
              }

              if (!chosenGenId) return;
              const srcGen = genById[chosenGenId];
              if (!srcGen || srcGen.type !== "list" || !Array.isArray(srcGen.items) || !srcGen.items.length) return;

              const value = rand(srcGen.items);
              const re = new RegExp("\\{" + tok.replace(/[.*+?^${}()|[\\]\\\\]/g, "\\$&") + "\\}", "g");
              result = result.replace(re, value);
            });

            const div = document.createElement("div");
            div.className = "generated-item";
            div.textContent = result;
            frag.appendChild(div);
          }

          advResults.appendChild(frag);
          advResults.addEventListener("click", handleCopyClick);
        });

        return;
      }

      panel.innerHTML = `<div class="muted">Unknown generator type.</div>`;
    }

    function openNewGeneratorBox() {
      editingGeneratorId = null;
      const box = document.getElementById("generatorCreateBox");
      const msg = document.getElementById("generatorCreateMessage");
      const nameInput   = document.getElementById("genNameInput");
      const itemsInput  = document.getElementById("genItemsInput");
      const saveBtn     = document.getElementById("saveGeneratorBtn");
      const expandBtn   = document.getElementById("expandItemsBtn");
      const typeInput   = document.getElementById("genTypeInput");
      const newFolderInput = document.getElementById("genFolderNewInput");
      const itemsRow = document.getElementById("genItemsRow");

      populateFolderSelect("General");

      nameInput.value = "";
      itemsInput.value = "";
      itemsInput.classList.remove("items-expanded");
      itemsExpanded = false;
      expandBtn.textContent = "Expand list editor";
      msg.textContent = "";
      msg.classList.remove("danger");
      saveBtn.textContent = "Save generator";
      typeInput.disabled = false;
      typeInput.value = "list";
      newFolderInput.value = "";
      newFolderInput.style.display = "none";

      itemsRow.style.display = "block";

      box.style.display = "flex";
    }

    function openEditGeneratorBox(genId) {
      const gens = loadGenerators();
      const gen = gens.find(g => g.id === genId);
      if (!gen) return;

      editingGeneratorId = genId;
      const box = document.getElementById("generatorCreateBox");
      const msg = document.getElementById("generatorCreateMessage");
      const nameInput   = document.getElementById("genNameInput");
      const itemsInput  = document.getElementById("genItemsInput");
      const saveBtn     = document.getElementById("saveGeneratorBtn");
      const expandBtn   = document.getElementById("expandItemsBtn");
      const typeInput   = document.getElementById("genTypeInput");
      const newFolderInput = document.getElementById("genFolderNewInput");
      const itemsRow = document.getElementById("genItemsRow");

      populateFolderSelect(gen.folder || "General");

      nameInput.value   = gen.name || "";
      msg.textContent = "";
      msg.classList.remove("danger");

      if (gen.type === "lexicon") {
        const arr = Array.isArray(gen.items) ? gen.items : [];
        itemsInput.value = arr.map(e => `${e.english} = ${e.valathi}`).join("\n");
        itemsRow.style.display = "block";
      } else if (gen.type === "list") {
        const arr = Array.isArray(gen.items) ? gen.items : [];
        itemsInput.value = arr.join("\n");
        itemsRow.style.display = "block";
      } else {
        itemsInput.value = "";
        itemsRow.style.display = "none";
      }

      itemsInput.classList.remove("items-expanded");
      itemsExpanded = false;
      expandBtn.textContent = "Expand list editor";

      saveBtn.textContent = "Save changes";

      typeInput.disabled = true;
      typeInput.value = gen.type;
      newFolderInput.value = "";
      newFolderInput.style.display = "none";

      box.style.display = "flex";
    }

    function hideGeneratorCreateBox() {
      const box = document.getElementById("generatorCreateBox");
      const msg = document.getElementById("generatorCreateMessage");
      const itemsInput  = document.getElementById("genItemsInput");
      const expandBtn   = document.getElementById("expandItemsBtn");
      const newFolderInput = document.getElementById("genFolderNewInput");

      document.getElementById("genNameInput").value = "";
      itemsInput.value = "";
      msg.textContent = "";
      msg.classList.remove("danger");
      editingGeneratorId = null;

      itemsInput.classList.remove("items-expanded");
      itemsExpanded = false;
      expandBtn.textContent = "Expand list editor";
      newFolderInput.value = "";
      newFolderInput.style.display = "none";

      box.style.display = "none";
    }

    function handleSaveGenerator() {
      const folderSelect = document.getElementById("genFolderSelect");
      const folderNewInput = document.getElementById("genFolderNewInput");
      const nameInput   = document.getElementById("genNameInput");
      const itemsInput  = document.getElementById("genItemsInput");
      const msg         = document.getElementById("generatorCreateMessage");
      const typeInput   = document.getElementById("genTypeInput");

      const typeValue = typeInput.value || "list";

      let folder = "";
      if (folderSelect.value === "__new__") {
        folder = (folderNewInput.value || "").trim() || "General";
      } else {
        folder = folderSelect.value || "General";
      }

      const name   = (nameInput.value || "").trim();
      const raw    = itemsInput.value || "";

      if (!name) {
        msg.textContent = "Please enter a name for the generator.";
        msg.classList.add("danger");
        return;
      }

      const gens = loadGenerators();

      if (editingGeneratorId) {
        const idx = gens.findIndex(g => g.id === editingGeneratorId);
        if (idx === -1) return;

        const existingType = gens[idx].type || "list";

        gens[idx].folder = folder;
        gens[idx].name   = name;

        if (existingType === "list" || existingType === "lexicon") {
          let parsed;
          if (existingType === "lexicon") {
            parsed = parseLexiconText(raw);
          } else {
            parsed = parseGeneratorItems(raw);
          }

          if (!parsed.items.length) {
            msg.textContent = existingType === "lexicon"
              ? "Please provide at least one valid 'english = valathi' entry."
              : "Please provide at least one non-empty item.";
            msg.classList.add("danger");
            return;
          }

          gens[idx].items  = parsed.items;
          gens[idx].type   = existingType;

          saveGenerators(gens);
          msg.classList.remove("danger");
          msg.textContent = `Updated “${name}” with ${parsed.items.length} entries. ${
            parsed.duplicates > 0 ? parsed.duplicates + " duplicates removed." : "No duplicates detected."
          }`;
        } else {
          saveGenerators(gens);
          msg.classList.remove("danger");
          msg.textContent = `Updated “${name}” (advanced generator). Edit patterns & mappings in the main panel.`;
        }

        activeGenerator = { id: editingGeneratorId };
        editingGeneratorId = null;
      } else {
        if (typeValue === "advanced") {
          const id = "gen-" + Date.now() + "-" + Math.floor(Math.random() * 10000);
          gens.push({
            id,
            folder,
            name,
            type: "advanced",
            items: { patterns: [], tokenMap: {}, multiTokenMap: {} }
          });
          saveGenerators(gens);
          msg.classList.remove("danger");
          msg.textContent = `Saved advanced generator “${name}” in folder “${folder}”. Configure patterns & mappings in the main panel.`;
          activeGenerator = { id };
        } else {
          let parsed;
          if (typeValue === "lexicon") {
            parsed = parseLexiconText(raw);
          } else {
            parsed = parseGeneratorItems(raw);
          }

          if (!parsed.items.length) {
            msg.textContent = typeValue === "lexicon"
              ? "Please provide at least one valid 'english = valathi' entry."
              : "Please provide at least one non-empty item.";
            msg.classList.add("danger");
            return;
          }

          const id = "gen-" + Date.now() + "-" + Math.floor(Math.random() * 10000);
          gens.push({ id, folder, name, type: typeValue, items: parsed.items });
          saveGenerators(gens);
          msg.classList.remove("danger");
          msg.textContent = `Saved “${name}” in folder “${folder}” with ${parsed.items.length} entries. ${
            parsed.duplicates > 0 ? parsed.duplicates + " duplicates removed." : "No duplicates detected."
          }`;
          activeGenerator = { id };
        }
      }

      renderGeneratorNav();
      renderActiveGeneratorPanel();

      setTimeout(() => {
        hideGeneratorCreateBox();
      }, 1200);
    }

    function toggleItemsExpand() {
      const ta = document.getElementById("genItemsInput");
      const btn = document.getElementById("expandItemsBtn");
      itemsExpanded = !itemsExpanded;
      if (itemsExpanded) {
        ta.classList.add("items-expanded");
        btn.textContent = "Collapse list editor";
      } else {
        ta.classList.remove("items-expanded");
        btn.textContent = "Expand list editor";
      }
    }

    function handleDownloadDatabase() {
      const gens = loadGenerators();
      const dataStr = JSON.stringify(gens, null, 2);
      const blob = new Blob([dataStr], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "vrahune_generators.json";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function handleNavClick(event) {
      const renameBtn = event.target.closest(".folder-rename-btn");
      if (renameBtn) {
        const heading = renameBtn.closest(".nav-folder-heading");
        if (!heading) return;
        const folder = heading.dataset.folder;
        if (!folder) return;
        const newName = window.prompt("Rename folder:", folder);
        if (!newName) return;
        const trimmed = newName.trim();
        if (!trimmed || trimmed === folder) return;

        const gens = loadGenerators();
        gens.forEach(g => {
          if ((g.folder || "General") === folder) {
            g.folder = trimmed;
          }
        });
        saveGenerators(gens);

        if (folderState[folder]) {
          folderState[trimmed] = folderState[folder];
          delete folderState[folder];
          saveFolderState();
        }

        renderGeneratorNav();
        renderActiveGeneratorPanel();
        populateFolderSelect(trimmed);
        return;
      }

      const folderToggle = event.target.closest(".folder-toggle");
      if (folderToggle) {
        const heading = folderToggle.closest(".nav-folder-heading");
        if (!heading) return;
        const folder = heading.dataset.folder;
        if (!folder) return;
        const current = folderState[folder] && folderState[folder].collapsed;
        if (!folderState[folder]) folderState[folder] = {};
        folderState[folder].collapsed = !current;
        saveFolderState();
        renderGeneratorNav();
        return;
      }

      const genItem = event.target.closest(".nav-generator");
      if (genItem) {
        const id = genItem.dataset.id;
        if (!id) return;
        activeGenerator = { id };
        renderGeneratorNav();
        renderActiveGeneratorPanel();
      }
    }

    async function initApp() {
      folderState = loadFolderState();

      const hasLocal = !!window.localStorage.getItem(GEN_STORAGE_KEY);
      if (!hasLocal) {
        const seeded = seedInitialGenerators();
        saveGenerators(seeded);
      }

      renderGeneratorNav();
      renderActiveGeneratorPanel();
      populateFolderSelect("General");
    }

    document.addEventListener("DOMContentLoaded", () => {
      document.getElementById("generatorNav").addEventListener("click", handleNavClick);
      document.getElementById("addGeneratorBtn").addEventListener("click", openNewGeneratorBox);
      document.getElementById("cancelGeneratorBtn").addEventListener("click", hideGeneratorCreateBox);
      document.getElementById("saveGeneratorBtn").addEventListener("click", handleSaveGenerator);
      document.getElementById("expandItemsBtn").addEventListener("click", toggleItemsExpand);
      document.getElementById("downloadDbBtn").addEventListener("click", handleDownloadDatabase);

      const folderSelect = document.getElementById("genFolderSelect");
      if (folderSelect) {
        folderSelect.addEventListener("change", handleFolderSelectChange);
      }

      const searchInput = document.getElementById("generatorSearchInput");
      if (searchInput) {
        searchInput.addEventListener("input", (e) => {
          generatorSearchTerm = e.target.value || "";
          renderGeneratorNav();
        });
      }

      const toggleCleanerBtn = document.getElementById("toggleTextCleanerBtn");
      const cleanerBody = document.getElementById("textCleanerBody");
      if (toggleCleanerBtn && cleanerBody) {
        toggleCleanerBtn.addEventListener("click", () => {
          const isHidden = cleanerBody.style.display === "none";
          cleanerBody.style.display = isHidden ? "block" : "none";
          toggleCleanerBtn.textContent = isHidden ? "Hide" : "Show";
        });
      }

      const cleanRunBtn = document.getElementById("cleanRunBtn");
      const cleanCopyBtn = document.getElementById("cleanCopyBtn");
      const cleanInput = document.getElementById("cleanInput");
      const cleanOutput = document.getElementById("cleanOutput");

      if (cleanRunBtn && cleanInput && cleanOutput) {
        cleanRunBtn.addEventListener("click", () => {
          const raw = cleanInput.value || "";
          const cleaned = cleanTextForGenerator(raw);
          cleanOutput.value = cleaned;
        });

        cleanCopyBtn.addEventListener("click", () => {
          const val = cleanOutput.value || "";
          if (!val.trim()) return;
          if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard.writeText(val)
              .then(() => showCopyMessage(val.split("\n")[0] + (val.includes("\n") ? " ..." : "")))
              .catch(() => showCopyMessage("Cleaned text"));
          } else {
            showCopyMessage("Cleaned text");
          }
        });
      }

      initApp();
    });
  </script>
</body>
</html>
