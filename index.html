<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Vrahune Generator Hub</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    :root {
      --bg: #050505;
      --bg-alt: #101010;
      --accent: #c0c0c0;          /* silver */
      --accent-soft: rgba(192,192,192,0.22);
      --text: #f5f5f5;
      --muted: #a0a0a0;
      --border: #2a2a2a;
      --danger: #ff8080;
      --shadow-soft: 0 14px 40px rgba(0, 0, 0, 0.75);
      --radius-lg: 16px;
    }

    * {
      box-sizing: border-box;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      margin: 0;
      padding: 0;
      background: radial-gradient(circle at top, #222 0, #050505 55%, #000 100%);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      align-items: stretch;
      justify-content: center;
    }

    .app-shell {
      max-width: 1200px;
      width: 100%;
      padding: 24px;
    }

    .card {
      background: linear-gradient(145deg, rgba(8, 8, 8, 0.97), rgba(4, 4, 4, 0.99));
      border-radius: var(--radius-lg);
      border: 1px solid var(--border);
      box-shadow: var(--shadow-soft);
      padding: 20px 20px 18px;
      backdrop-filter: blur(10px);
    }

    h1, h2, h3 {
      margin: 0 0 8px;
      font-weight: 600;
      letter-spacing: 0.02em;
    }

    h1 {
      font-size: 1.4rem;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    h1 span.logo {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 26px;
      height: 26px;
      border-radius: 999px;
      border: 1px solid rgba(192,192,192,0.55);
      background: radial-gradient(circle at top, rgba(230,230,230,0.25), transparent 60%);
      font-size: 0.9rem;
      color: var(--text);
    }

    .subtitle {
      font-size: 0.85rem;
      color: var(--muted);
      margin-bottom: 16px;
    }

    label {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
      display: block;
      margin-bottom: 4px;
    }

    input[type="text"],
    input[type="number"],
    textarea,
    select {
      width: 100%;
      padding: 8px 9px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(12, 12, 12, 0.95);
      color: var(--text);
      font-size: 0.9rem;
      outline: none;
      transition: border-color 0.18s ease, box-shadow 0.18s ease, background 0.18s ease;
    }

    input[type="text"]:focus,
    input[type="number"]:focus,
    textarea:focus,
    select:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent-soft);
      background: rgba(18, 18, 18, 1);
    }

    textarea {
      resize: vertical;
      min-height: 120px;
    }

    button {
      border-radius: 999px;
      border: 1px solid transparent;
      padding: 7px 14px;
      font-size: 0.85rem;
      font-weight: 500;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: transform 0.12s ease, box-shadow 0.12s ease, background 0.12s ease, border-color 0.12s ease;
    }

    .btn-primary {
      background: linear-gradient(135deg, #f5f5f5, #bfbfbf);
      color: #111;
      box-shadow: 0 8px 22px rgba(200, 200, 200, 0.4);
    }

    .btn-primary:hover {
      transform: translateY(-1px);
      box-shadow: 0 12px 30px rgba(230, 230, 230, 0.6);
    }

    .btn-secondary {
      background: transparent;
      border-color: var(--border);
      color: var(--muted);
    }

    .btn-secondary:hover {
      border-color: var(--accent-soft);
      background: rgba(18, 18, 18, 0.96);
    }

    .btn-small {
      padding: 4px 10px;
      font-size: 0.8rem;
    }

    .btn-icon {
      width: 26px;
      height: 26px;
      border-radius: 8px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      font-size: 1rem;
      border-color: var(--border);
    }

    .btn-icon:hover {
      border-color: var(--accent);
      background: rgba(255, 255, 255, 0.04);
    }

    .row {
      display: flex;
      gap: 10px;
      align-items: flex-end;
      margin-bottom: 12px;
      flex-wrap: wrap;
    }

    .col {
      flex: 1;
      min-width: 140px;
    }

    .section-title {
      font-size: 0.95rem;
      margin-bottom: 6px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .section-title span {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .muted {
      color: var(--muted);
      font-size: 0.8rem;
    }

    hr {
      border: none;
      border-top: 1px solid var(--border);
      margin: 16px 0;
    }

    .danger {
      color: var(--danger);
    }

    /* Layout: left nav, right panel */
    .hub-body {
      display: flex;
      gap: 16px;
      margin-top: 8px;
    }

    .nav-column {
      width: 280px;
      min-width: 240px;
      max-width: 320px;
      display: flex;
      flex-direction: column;
    }

    .detail-column {
      flex: 1;
      min-width: 0;
      display: flex;
      flex-direction: column;
    }

    @media (max-width: 900px) {
      .hub-body {
        flex-direction: column;
      }
      .nav-column {
        width: 100%;
        max-width: 100%;
      }
    }

    /* NAV AREA (folders + generators) */
    .nav-area {
      border-radius: 12px;
      border: 1px solid rgba(60,60,60,0.9);
      background: linear-gradient(180deg, rgba(10,10,10,0.98), rgba(5,5,5,0.98));
      padding: 6px 8px;
      max-height: 360px;
      overflow-y: auto;
      margin-top: 8px;
      margin-bottom: 12px;
    }

    .nav-folder-heading {
      font-size: 0.78rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.11em;
      margin: 6px 4px 2px;
    }

    .nav-generator {
      font-size: 0.86rem;
      padding: 5px 8px;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: flex-start;
      gap: 6px;
      margin: 2px 2px;
      border: 1px solid transparent;
    }

    .nav-generator span.name {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .nav-generator:hover {
      border-color: var(--border);
      background: rgba(255,255,255,0.03);
    }

    .nav-generator.active {
      border-color: var(--accent);
      background: rgba(255,255,255,0.06);
    }

    .folder-badge {
      font-size: 0.75rem;
      opacity: 0.8;
    }

    /* Create / edit box */
    .create-box {
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px dashed rgba(120,120,120,0.7);
      background: rgba(10,10,10,0.95);
    }

    /* Active generator panel */
    .generator-panel {
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(70,70,70,0.9);
      background: radial-gradient(circle at top left, rgba(255,255,255,0.05), rgba(8,8,8,0.96));
      min-height: 80px;
      margin-top: 8px;
    }

    .generator-title-main {
      font-size: 1rem;
      font-weight: 600;
      margin-bottom: 4px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .generated-list {
      margin-top: 8px;
      padding: 6px 8px;
      border-radius: 10px;
      border: 1px solid rgba(45,45,45,0.9);
      background: rgba(8,8,8,0.98);
      max-height: 220px;
      overflow-y: auto;
      font-size: 0.88rem;
    }

    .generated-item {
      padding: 3px 0;
      cursor: pointer;
    }

    .generated-item:hover {
      text-decoration: underline;
    }

    .copy-message {
      margin-top: 6px;
      font-size: 0.78rem;
      color: var(--muted);
    }

    .items-expanded {
      min-height: 260px !important;
      max-height: 70vh;
    }
  </style>
</head>
<body>
  <div class="app-shell">
    <div class="card">
      <h1>
        <span class="logo">V</span>
        Vrahune Generator Hub
      </h1>
      <div class="subtitle">
        Left: folders & generators (including lexicons). Right: generator controls & results.
      </div>

      <div class="hub-body">
        <!-- LEFT: NAV / FOLDERS -->
        <div class="nav-column">
          <div class="section-title">
            <span>Generators</span>
            <button id="addGeneratorBtn" class="btn-secondary btn-icon" title="Create new generator">
              ＋
            </button>
          </div>

          <div id="generatorCreateBox" class="create-box" style="display:none;">
            <div class="muted" style="margin-bottom:6px;">
              Create or edit a generator. Items can be names, lexicon entries, book titles, etc.
              One per line. Duplicates are removed automatically.
            </div>

            <div class="row">
              <div class="col">
                <label for="genFolderSelect">Folder</label>
                <select id="genFolderSelect"></select>
                <input id="genFolderNewInput" type="text" placeholder="New folder name" style="display:none; margin-top:4px;">
              </div>
              <div class="col">
                <label for="genNameInput">Generator name</label>
                <input id="genNameInput" type="text" placeholder="e.g. Valathi Lexicon, Tavern Names">
              </div>
              <div class="col">
                <label for="genTypeInput">Type</label>
                <select id="genTypeInput">
                  <option value="list">Random list</option>
                  <option value="lexicon">Lexicon translator</option>
                </select>
              </div>
            </div>

            <div class="row">
              <div class="col">
                <label for="genItemsInput">Items list</label>
                <textarea id="genItemsInput" placeholder="For list: one item per line&#10;For lexicon: english = valathi"></textarea>
                <button type="button" id="expandItemsBtn" class="btn-secondary btn-small" style="margin-top:4px;">
                  Expand list editor
                </button>
              </div>
            </div>

            <div class="row">
              <button id="saveGeneratorBtn" class="btn-primary">
                Save generator
              </button>
              <button id="cancelGeneratorBtn" class="btn-secondary">
                Cancel
              </button>
            </div>

            <div id="generatorCreateMessage" class="muted"></div>
          </div>

          <div id="generatorNav" class="nav-area"></div>
        </div>

        <!-- RIGHT: ACTIVE GENERATOR PANEL -->
        <div class="detail-column">
          <div class="section-title">
            <span id="activeGeneratorLabel">No generator selected</span>
          </div>

          <div id="generatorPanel" class="generator-panel">
            <div class="muted">
              Choose a generator from the left, or click ＋ to create one. This panel will show its controls and results.
            </div>
          </div>

          <div id="copyMessage" class="copy-message">
            Click any generated item or lexicon entry to copy.
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // --------------------------------
    // STORAGE & STATE
    // --------------------------------
    const GEN_STORAGE_KEY = "vrahuneGeneratorsV3";

    // generator: { id, folder, name, type: "list"|"elf"|"book"|"lexicon", items }
    // list:  items = [ "string", ... ]
    // lexicon: items = [ { english, valathi }, ... ]

    let activeGenerator = null;
    let editingGeneratorId = null;
    let itemsExpanded = false;

    // --------------------------------
    // VALATHI LEXICON SEED
    // --------------------------------
    const valathiLexiconSeed = [
      { english: "high, noble, elevated, bright", valathi: "val" },
      { english: "forest, wooded land", valathi: "’ath" },
      { english: "land, domain", valathi: "anna" },
      { english: "seat, city, foundation", valathi: "dor" },
      { english: "stone, mountain, cliff", valathi: "vor" },
      { english: "water, lake", valathi: "mir" },
      { english: "river, flowing path", valathi: "len" },
      { english: "wind, air current", valathi: "vrae" },
      { english: "star, light in the dark", valathi: "sel" },
      { english: "sea, great water", valathi: "thal" },
      { english: "north, cold lands", valathi: "nor" },
      { english: "dusk, evening star", valathi: "ves" },
      { english: "guardian, warden", valathi: "vel" },
      { english: "song, art, beautiful craft", valathi: "rin" },
      { english: "lore, deep knowledge", valathi: "ith" },
      { english: "peace, calm", valathi: "ser" },
      { english: "flame, passion, drive", valathi: "nar" },
      { english: "life, breath, vitality", valathi: "laen" },
      { english: "hidden, secret, veiled", valathi: "vyn" },
      { english: "world, the continent", valathi: "Vrahune" },
      { english: "noble-forest land (realm)", valathi: "Val’athanna" },
      { english: "high seat, noble city", valathi: "Valdora" }
    ];

    // --------------------------------
    // HELPERS
    // --------------------------------
    function rand(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }

    function showCopyMessage(text) {
      const msg = document.getElementById("copyMessage");
      msg.textContent = `Copied: "${text}"`;
      setTimeout(() => {
        msg.textContent = "Click any generated item or lexicon entry to copy.";
      }, 2500);
    }

    function handleCopyClick(event) {
      const target = event.target;
      if (!target.classList.contains("generated-item")) return;
      const text = target.textContent.trim();
      if (!text) return;
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(text)
          .then(() => showCopyMessage(text))
          .catch(() => showCopyMessage(text));
      } else {
        showCopyMessage(text);
      }
    }

    // --------------------------------
    // BUILT-IN LOGIC (elf names & book titles)
    // --------------------------------
    const elfStartsClassic = [
      "Val", "Ves", "Vor", "Vrae", "Sel", "Thal", "Mir", "Nor", "Lae", "Vel", "Vyn", "Maer"
    ];

    const elfStartsNewGen = [
      "Ael", "Ny", "Syl", "Cae", "Ari", "Eli", "Var", "Lor", "Sael", "Cal", "Ser", "Ty", "Vael", "Oryn"
    ];

    const elfMiddles = [
      "a", "e", "i", "o", "la", "le", "li", "ra", "re", "ri", "sa", "se", "thal", "lyn", "rin"
    ];

    const elfEndNeutral = [
      "en", "el", "eth", "ir", "is", "as", "or", "ar", "ion", "iel", "ira", "yn"
    ];

    const elfEndSoft = [
      "a", "ae", "ira", "iel", "essa", "yn", "yne", "ara", "ina"
    ];

    const elfEndSharp = [
      "as", "ix", "or", "eth", "is", "ar", "ax", "an", "orix"
    ];

    function generateSingleElfName(style, tone) {
      const startPool = style === "valathi-classic" ? elfStartsClassic : elfStartsNewGen;
      let endPool = elfEndNeutral;

      if (tone === "soft") {
        endPool = elfEndSoft;
      } else if (tone === "sharp") {
        endPool = elfEndSharp;
      }

      const start = rand(startPool);
      const useMiddle = Math.random() < 0.55;
      let middle = "";
      if (useMiddle) {
        middle = rand(elfMiddles);
      }
      const end = rand(endPool);

      const raw = start + middle + end;
      return raw.charAt(0).toUpperCase() + raw.slice(1);
    }

    const bookAdjCommon = [
      "Silent", "Forgotten", "Gilded", "Broken", "Crimson", "Twilight", "Shattered",
      "Hidden", "Last", "Bound", "Whispering", "Silver", "Onyx", "Verdant", "Burning", "Veiled"
    ];

    const bookNounCommon = [
      "Throne", "Forest", "Empire", "Oath", "Crown", "River", "Sea", "Spire",
      "Song", "Shadow", "Light", "Wolf", "King", "Queen", "Chronicle", "Blade", "Storm", "Gate"
    ];

    const bookOfPhrases = [
      "of Vrahune",
      "of the Valathar",
      "of the North",
      "of the Verdant Veil",
      "of the Onyx Empire",
      "of the Fallen Spears",
      "of the Dawn War",
      "of the Silver Mountain"
    ];

    const bookValathiBits = [
      "Val’athanna", "Valdora", "Vrahune", "Saelvorion",
      "Lir’ath", "Vraedor", "Mirlen", "Nor’thal", "Vesnar"
    ];

    function generateSingleBookTitle(flavor) {
      const pattern = Math.floor(Math.random() * 3);

      const adj = rand(bookAdjCommon);
      const noun1 = rand(bookNounCommon);
      const noun2 = rand(bookNounCommon.filter(n => n !== noun1));
      const ofPhrase = bookOfPhrases[Math.floor(Math.random() * bookOfPhrases.length)];

      if (flavor === "common") {
        if (pattern === 0) {
          return `The ${adj} ${noun1}`;
        } else if (pattern === 1) {
          return `${noun1} of ${noun2}`;
        } else {
          return `The ${noun1} ${ofPhrase}`;
        }
      } else {
        const valBit = rand(bookValathiBits);
        if (pattern === 0) {
          return `The ${adj} ${noun1} of ${valBit}`;
        } else if (pattern === 1) {
          return `${noun1} of ${valBit}`;
        } else {
          return `${valBit}: The ${adj} ${noun1}`;
        }
      }
    }

    // --------------------------------
    // GENERATOR STORAGE
    // --------------------------------
    function seedInitialGenerators() {
      return [
        {
          id: "gen-elf",
          folder: "Names",
          name: "Elf Names (Valathar)",
          type: "elf",
          items: []
        },
        {
          id: "gen-book",
          folder: "Names",
          name: "Book Titles",
          type: "book",
          items: []
        },
        {
          id: "gen-lex-valathi",
          folder: "Lexicons",
          name: "Valathi Lexicon",
          type: "lexicon",
          items: valathiLexiconSeed
        }
      ];
    }

    function loadGenerators() {
      try {
        const raw = window.localStorage.getItem(GEN_STORAGE_KEY);
        if (!raw) {
          const seeded = seedInitialGenerators();
          saveGenerators(seeded);
          return seeded;
        }
        const parsed = JSON.parse(raw);
        if (!Array.isArray(parsed) || parsed.length === 0) {
          const seeded = seedInitialGenerators();
          saveGenerators(seeded);
          return seeded;
        }
        return parsed.map(g => ({
          ...g,
          type: g.type || "list",
          items: Array.isArray(g.items) ? g.items : []
        }));
      } catch {
        const seeded = seedInitialGenerators();
        saveGenerators(seeded);
        return seeded;
      }
    }

    function saveGenerators(list) {
      try {
        window.localStorage.setItem(GEN_STORAGE_KEY, JSON.stringify(list));
      } catch {}
    }

    function parseGeneratorItems(rawText) {
      if (!rawText) return { items: [], duplicates: 0 };
      const lines = rawText.split(/\r?\n/);
      const set = new Set();
      const items = [];
      let total = 0;

      for (const line of lines) {
        const t = line.trim();
        if (!t) continue;
        total++;
        const key = t.toLowerCase();
        if (!set.has(key)) {
          set.add(key);
          items.push(t);
        }
      }
      const duplicates = Math.max(0, total - items.length);
      return { items, duplicates };
    }

    function parseLexiconText(rawText) {
      if (!rawText) return { items: [], duplicates: 0 };
      const lines = rawText.split(/\r?\n/);
      const map = new Map();
      let total = 0;

      for (const line of lines) {
        const t = line.trim();
        if (!t) continue;
        total++;
        let english = "";
        let valathi = "";

        const eqIdx = t.indexOf("=");
        const dashIdx = (eqIdx === -1) ? t.indexOf("-") : -1;

        if (eqIdx !== -1) {
          english = t.slice(0, eqIdx).trim();
          valathi = t.slice(eqIdx + 1).trim();
        } else if (dashIdx !== -1) {
          english = t.slice(0, dashIdx).trim();
          valathi = t.slice(dashIdx + 1).trim();
        } else {
          english = t;
          valathi = t;
        }

        if (!english || !valathi) continue;
        const key = `${english.toLowerCase()}|${valathi.toLowerCase()}`;
        if (!map.has(key)) {
          map.set(key, { english, valathi });
        }
      }

      const items = Array.from(map.values());
      const duplicates = Math.max(0, total - items.length);
      return { items, duplicates };
    }

    function mergeLexiconEntries(existing, incoming) {
      const map = new Map();
      if (Array.isArray(existing)) {
        for (const e of existing) {
          if (!e || !e.english || !e.valathi) continue;
          const key = `${String(e.english).toLowerCase()}|${String(e.valathi).toLowerCase()}`;
          map.set(key, { english: e.english, valathi: e.valathi });
        }
      }
      if (Array.isArray(incoming)) {
        for (const e of incoming) {
          if (!e || !e.english || !e.valathi) continue;
          const key = `${String(e.english).toLowerCase()}|${String(e.valathi).toLowerCase()}`;
          map.set(key, { english: e.english, valathi: e.valathi });
        }
      }
      return Array.from(map.values());
    }

    // --------------------------------
    // FOLDER SELECT (new behavior)
    // --------------------------------
    function populateFolderSelect(selectedFolder) {
      const select = document.getElementById("genFolderSelect");
      if (!select) return;

      const gens = loadGenerators();
      const folderSet = new Set();

      gens.forEach(g => {
        const f = g.folder || "General";
        folderSet.add(f);
      });

      const folderNames = Array.from(folderSet).sort((a, b) => a.localeCompare(b));

      // if selected folder doesn't exist yet (e.g. editing), include it
      if (selectedFolder && selectedFolder !== "__new__" && !folderSet.has(selectedFolder)) {
        folderNames.push(selectedFolder);
      }

      select.innerHTML = "";

      // add existing folders
      folderNames.forEach(f => {
        const opt = document.createElement("option");
        opt.value = f;
        opt.textContent = f;
        select.appendChild(opt);
      });

      // + new folder option
      const optNew = document.createElement("option");
      optNew.value = "__new__";
      optNew.textContent = "+ New folder…";
      select.appendChild(optNew);

      // set selected value
      if (selectedFolder && selectedFolder !== "__new__" && folderNames.includes(selectedFolder)) {
        select.value = selectedFolder;
      } else if (folderNames.length > 0) {
        select.value = folderNames[0];
      } else {
        // no existing folders: default to new
        select.value = "__new__";
      }

      handleFolderSelectChange(); // ensure new-folder input visibility is correct
    }

    function handleFolderSelectChange() {
      const select = document.getElementById("genFolderSelect");
      const newInput = document.getElementById("genFolderNewInput");
      if (!select || !newInput) return;

      if (select.value === "__new__") {
        newInput.style.display = "block";
      } else {
        newInput.style.display = "none";
        newInput.value = "";
      }
    }

    // --------------------------------
    // NAV RENDERING
    // --------------------------------
    function renderGeneratorNav() {
      const nav = document.getElementById("generatorNav");
      nav.innerHTML = "";

      const gens = loadGenerators();
      const folderMap = {};

      gens.forEach(gen => {
        const folder = gen.folder || "General";
        if (!folderMap[folder]) folderMap[folder] = [];
        folderMap[folder].push(gen);
      });

      const folderNames = Object.keys(folderMap).sort((a, b) => a.localeCompare(b));

      if (!folderNames.length) {
        nav.innerHTML = `<div class="muted" style="font-size:0.8rem; padding:4px 4px 8px;">No generators yet. Click ＋ to create one.</div>`;
        return;
      }

      folderNames.forEach(folder => {
        const heading = document.createElement("div");
        heading.className = "nav-folder-heading";
        heading.innerHTML = `${folder} <span class="folder-badge">(${folderMap[folder].length})</span>`;
        nav.appendChild(heading);

        folderMap[folder]
          .sort((a,b) => a.name.localeCompare(b.name))
          .forEach(gen => {
            const item = document.createElement("div");
            item.className = "nav-generator";
            item.dataset.id = gen.id;

            const isActive = activeGenerator && activeGenerator.id === gen.id;
            if (isActive) item.classList.add("active");

            item.innerHTML = `<span class="name">${gen.name}</span>`;
            nav.appendChild(item);
          });
      });
    }

    // --------------------------------
    // ACTIVE GENERATOR PANEL
    // --------------------------------
    function renderActiveGeneratorPanel() {
      const label = document.getElementById("activeGeneratorLabel");
      const panel = document.getElementById("generatorPanel");
      panel.innerHTML = "";
      panel.removeEventListener("click", handleCopyClick); // safety

      if (!activeGenerator) {
        label.textContent = "No generator selected";
        panel.innerHTML = `<div class="muted">Choose a generator from the left, or click ＋ to create one.</div>`;
        return;
      }

      const gens = loadGenerators();
      const gen = gens.find(g => g.id === activeGenerator.id);
      if (!gen) {
        label.textContent = "Generator not found";
        panel.innerHTML = `<div class="muted">This generator no longer exists. Choose another one.</div>`;
        return;
      }

      label.textContent = `${gen.name} (${gen.folder || "General"})`;

      // ELF NAMES
      if (gen.type === "elf") {
        panel.innerHTML = `
          <div class="generator-title-main">
            ${gen.name}
          </div>
          <div class="muted" style="margin-bottom:8px;">
            Generates Valathar-style names (classic Valathi or newer, mixed-region vibes).
          </div>
          <div class="row">
            <div class="col">
              <label for="elfStyle">Style</label>
              <select id="elfStyle">
                <option value="valathi-classic">Valathi Classic</option>
                <option value="new-gen">New Gen / Mixed</option>
              </select>
            </div>
            <div class="col">
              <label for="elfTone">Tone</label>
              <select id="elfTone">
                <option value="neutral">Neutral</option>
                <option value="soft">Soft-leaning</option>
                <option value="sharp">Sharp/edgy</option>
              </select>
            </div>
            <div class="col">
              <label for="elfCount">Count</label>
              <input id="elfCount" type="number" min="1" max="30" value="10">
            </div>
          </div>
          <div class="row">
            <button id="elfGenerateBtn" class="btn-primary">Generate</button>
          </div>
          <div id="elfResults" class="generated-list" style="margin-top:8px;"></div>
        `;

        const btn = panel.querySelector("#elfGenerateBtn");
        const results = panel.querySelector("#elfResults");
        const styleSel = panel.querySelector("#elfStyle");
        const toneSel = panel.querySelector("#elfTone");
        const countInput = panel.querySelector("#elfCount");

        btn.addEventListener("click", () => {
          const style = styleSel.value;
          const tone = toneSel.value;
          const count = Math.max(1, Math.min(30, parseInt(countInput.value || "1", 10)));
          results.innerHTML = "";
          const frag = document.createDocumentFragment();
          for (let i = 0; i < count; i++) {
            const name = generateSingleElfName(style, tone);
            const div = document.createElement("div");
            div.className = "generated-item";
            div.textContent = name;
            frag.appendChild(div);
          }
          results.appendChild(frag);
        });

        results.addEventListener("click", handleCopyClick);
        return;
      }

      // BOOK TITLES
      if (gen.type === "book") {
        panel.innerHTML = `
          <div class="generator-title-main">
            ${gen.name}
          </div>
          <div class="muted" style="margin-bottom:8px;">
            Titles for tomes, legends, grimoires. Common tongue or Valathi-flavored.
          </div>
          <div class="row">
            <div class="col">
              <label for="bookFlavor">Flavor</label>
              <select id="bookFlavor">
                <option value="common">Common tongue</option>
                <option value="valathi">Valathi-flavored</option>
              </select>
            </div>
            <div class="col">
              <label for="bookCount">Count</label>
              <input id="bookCount" type="number" min="1" max="30" value="10">
            </div>
          </div>
          <div class="row">
            <button id="bookGenerateBtn" class="btn-primary">Generate</button>
          </div>
          <div id="bookResults" class="generated-list" style="margin-top:8px;"></div>
        `;

        const btn = panel.querySelector("#bookGenerateBtn");
        const results = panel.querySelector("#bookResults");
        const flavorSel = panel.querySelector("#bookFlavor");
        const countInput = panel.querySelector("#bookCount");

        btn.addEventListener("click", () => {
          const flavor = flavorSel.value;
          const count = Math.max(1, Math.min(30, parseInt(countInput.value || "1", 10)));
          results.innerHTML = "";
          const frag = document.createDocumentFragment();
          for (let i = 0; i < count; i++) {
            const title = generateSingleBookTitle(flavor);
            const div = document.createElement("div");
            div.className = "generated-item";
            div.textContent = title;
            frag.appendChild(div);
          }
          results.appendChild(frag);
        });

        results.addEventListener("click", handleCopyClick);
        return;
      }

      // LEXICON TRANSLATOR
      if (gen.type === "lexicon") {
        panel.innerHTML = `
          <div class="generator-title-main">
            ${gen.name}
          </div>
          <div class="muted" style="margin-bottom:8px;">
            Folder: ${gen.folder || "General"} · ${gen.items.length} lexicon entries.
          </div>

          <div class="row">
            <div class="col">
              <label for="lexMode">Direction</label>
              <select id="lexMode">
                <option value="en-to-va">Common → Valathi</option>
                <option value="va-to-en">Valathi → Common</option>
              </select>
            </div>
            <div class="col">
              <label for="lexQuery">Word</label>
              <input id="lexQuery" type="text" placeholder="Type a word to look up">
            </div>
            <div class="col">
              <label>&nbsp;</label>
              <button id="lexSearchBtn" class="btn-primary">Translate</button>
            </div>
          </div>

          <div id="lexResult" class="generated-list"></div>

          <hr>

          <div class="section-title">
            <span>Manage entries</span>
          </div>
          <div class="row">
            <div class="col">
              <label for="lexiconAddInput">Add entries (english = valathi)</label>
              <textarea id="lexiconAddInput" placeholder="high = val&#10;forest = ’ath"></textarea>
            </div>
          </div>
          <div class="row">
            <button id="lexAppendBtn" class="btn-secondary btn-small">Append from text</button>
            <button id="lexImportBtn" class="btn-secondary btn-small">Import from JSON/HTML</button>
            <button id="lexDownloadBtn" class="btn-secondary btn-small">Download JSON</button>
            <button id="lexOpenEditBtn" class="btn-secondary btn-small">Edit as raw</button>
          </div>
          <input type="file" id="lexFileInput" accept=".json,.txt,.html" style="display:none;">
          <div id="lexMessage" class="muted" style="margin-top:4px;"></div>

          <div class="section-title" style="margin-top:10px;">
            <span>All entries</span>
            <span class="muted" style="font-size:0.75rem;">Click to copy "english = valathi"</span>
          </div>
          <div id="lexAllEntries" class="generated-list"></div>
        `;

        const lexMode = panel.querySelector("#lexMode");
        const lexQuery = panel.querySelector("#lexQuery");
        const lexSearchBtn = panel.querySelector("#lexSearchBtn");
        const lexResult = panel.querySelector("#lexResult");
        const lexAllEntries = panel.querySelector("#lexAllEntries");
        const lexAddInput = panel.querySelector("#lexiconAddInput");
        const lexAppendBtn = panel.querySelector("#lexAppendBtn");
        const lexImportBtn = panel.querySelector("#lexImportBtn");
        const lexDownloadBtn = panel.querySelector("#lexDownloadBtn");
        const lexFileInput = panel.querySelector("#lexFileInput");
        const lexMessage = panel.querySelector("#lexMessage");
        const lexOpenEditBtn = panel.querySelector("#lexOpenEditBtn");

        function renderAllEntriesList(items) {
          lexAllEntries.innerHTML = "";
          const sorted = [...items].sort((a, b) =>
            String(a.english).localeCompare(String(b.english))
          );
          const frag = document.createDocumentFragment();
          for (const e of sorted) {
            const div = document.createElement("div");
            div.className = "generated-item";
            div.textContent = `${e.english} = ${e.valathi}`;
            frag.appendChild(div);
          }
          lexAllEntries.appendChild(frag);
        }

        function searchLexicon(items, query, mode) {
          const q = query.trim().toLowerCase();
          if (!q) return [];
          if (mode === "en-to-va") {
            return items.filter(e => String(e.english).toLowerCase().includes(q));
          } else {
            return items.filter(e => String(e.valathi).toLowerCase().includes(q));
          }
        }

        function doSearch() {
          const gensCurrent = loadGenerators();
          const g = gensCurrent.find(x => x.id === gen.id);
          if (!g) return;

          const items = Array.isArray(g.items) ? g.items : [];
          const mode = lexMode.value;
          const q = lexQuery.value;
          const matches = searchLexicon(items, q, mode);
          lexResult.innerHTML = "";

          if (!q.trim()) {
            lexResult.innerHTML = `<div class="muted">Type a word and click Translate.</div>`;
            return;
          }

          if (!matches.length) {
            lexResult.innerHTML = `<div class="muted">No entries found for "${q}".</div>`;
            return;
          }

          const frag = document.createDocumentFragment();
          for (const e of matches) {
            const div = document.createElement("div");
            div.className = "generated-item";
            if (mode === "en-to-va") {
              div.textContent = `${e.english} → ${e.valathi}`;
            } else {
              div.textContent = `${e.valathi} → ${e.english}`;
            }
            frag.appendChild(div);
          }
          lexResult.appendChild(frag);
        }

        lexSearchBtn.addEventListener("click", doSearch);
        lexQuery.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            doSearch();
          }
        });

        lexResult.addEventListener("click", handleCopyClick);
        lexAllEntries.addEventListener("click", handleCopyClick);

        // Append from text
        lexAppendBtn.addEventListener("click", () => {
          const raw = lexAddInput.value || "";
          if (!raw.trim()) {
            lexMessage.textContent = "No text to append.";
            return;
          }
          const { items: newItems, duplicates } = parseLexiconText(raw);
          if (!newItems.length) {
            lexMessage.textContent = "No valid entries found. Use 'english = valathi'.";
            return;
          }
          const gensCurrent = loadGenerators();
          const idx = gensCurrent.findIndex(x => x.id === gen.id);
          if (idx === -1) return;
          const before = Array.isArray(gensCurrent[idx].items) ? gensCurrent[idx].items : [];
          const merged = mergeLexiconEntries(before, newItems);
          const added = merged.length - before.length;

          gensCurrent[idx].items = merged;
          saveGenerators(gensCurrent);
          lexAddInput.value = "";

          lexMessage.textContent =
            `Appended ${added} entries. ${duplicates > 0 ? duplicates + " duplicate lines removed." : "No duplicates in input."}`;
          renderAllEntriesList(merged);
        });

        // Import from JSON/HTML
        lexImportBtn.addEventListener("click", () => {
          lexFileInput.value = "";
          lexFileInput.click();
        });

        lexFileInput.addEventListener("change", (e) => {
          const file = e.target.files && e.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = (ev) => {
            const text = ev.target.result;
            let imported = [];

            // Try JSON first
            try {
              const parsed = JSON.parse(text);
              if (Array.isArray(parsed)) {
                for (const item of parsed) {
                  if (!item) continue;
                  if (typeof item === "string") {
                    const { items } = parseLexiconText(item);
                    imported = imported.concat(items);
                  } else if (typeof item === "object") {
                    const english = item.english || item.en || item.word || item.key || "";
                    const valathi = item.valathi || item.va || item.value || "";
                    if (english && valathi) {
                      imported.push({ english, valathi });
                    }
                  }
                }
              } else if (typeof parsed === "object") {
                for (const key in parsed) {
                  if (!Object.prototype.hasOwnProperty.call(parsed, key)) continue;
                  const english = key;
                  const valathi = parsed[key];
                  if (english && valathi) {
                    imported.push({ english, valathi });
                  }
                }
              }
            } catch {
              // Not valid JSON; treat as raw text
              const { items } = parseLexiconText(text);
              imported = imported.concat(items);
            }

            if (!imported.length) {
              lexMessage.textContent = "No valid entries found in file.";
              return;
            }

            const gensCurrent = loadGenerators();
            const idx = gensCurrent.findIndex(x => x.id === gen.id);
            if (idx === -1) return;

            const before = Array.isArray(gensCurrent[idx].items) ? gensCurrent[idx].items : [];
            const merged = mergeLexiconEntries(before, imported);
            const added = merged.length - before.length;

            gensCurrent[idx].items = merged;
            saveGenerators(gensCurrent);
            lexMessage.textContent = `Imported ${added} new entries from file.`;
            renderAllEntriesList(merged);
          };
          reader.readAsText(file);
        });

        // Download JSON
        lexDownloadBtn.addEventListener("click", () => {
          const gensCurrent = loadGenerators();
          const g = gensCurrent.find(x => x.id === gen.id);
          if (!g) return;
          const dataStr = JSON.stringify(g.items || [], null, 2);
          const blob = new Blob([dataStr], { type: "application/json" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `${g.name.replace(/\s+/g, "_")}.json`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        });

        // Open raw editor (left create box)
        lexOpenEditBtn.addEventListener("click", () => {
          openEditGeneratorBox(gen.id);
        });

        // Initial list
        renderAllEntriesList(gen.items || []);
        return;
      }

      // LIST-BASED GENERATOR
      panel.innerHTML = `
        <div class="generator-title-main">
          ${gen.name}
        </div>
        <div class="muted" style="margin-bottom:8px;">
          Folder: ${gen.folder || "General"} · ${gen.items.length} items in pool.
        </div>
        <div class="row">
          <div class="col">
            <label for="customCountInput">Count</label>
            <input id="customCountInput" type="number" min="1" max="50" value="10">
          </div>
          <div class="col">
            <label>&nbsp;</label>
            <button id="customGenerateBtn" class="btn-primary">Generate</button>
          </div>
        </div>
        <div class="row">
          <button id="customEditBtn" class="btn-secondary btn-small">Edit items</button>
          <button id="customDeleteBtn" class="btn-secondary btn-small">Delete generator</button>
        </div>
        <div id="customResults" class="generated-list"></div>
      `;

      const countInput = panel.querySelector("#customCountInput");
      const genBtn = panel.querySelector("#customGenerateBtn");
      const editBtn = panel.querySelector("#customEditBtn");
      const delBtn  = panel.querySelector("#customDeleteBtn");
      const results = panel.querySelector("#customResults");

      genBtn.addEventListener("click", () => {
        const pool = [...gen.items];
        const count = Math.max(1, Math.min(50, parseInt(countInput.value || "1", 10)));
        results.innerHTML = "";
        const frag = document.createDocumentFragment();
        if (!pool.length) return;
        for (let i = 0; i < count; i++) {
          if (!pool.length) break;
          const idx = Math.floor(Math.random() * pool.length);
          const value = pool.splice(idx, 1)[0];
          const div = document.createElement("div");
          div.className = "generated-item";
          div.textContent = value;
          frag.appendChild(div);
        }
        results.appendChild(frag);
      });

      results.addEventListener("click", handleCopyClick);

      editBtn.addEventListener("click", () => {
        openEditGeneratorBox(gen.id);
      });

      delBtn.addEventListener("click", () => {
        const ok = window.confirm(`Delete generator “${gen.name}” from folder “${gen.folder || "General"}”?`);
        if (!ok) return;
        const newList = gens.filter(g => g.id !== gen.id);
        saveGenerators(newList);
        if (activeGenerator && activeGenerator.id === gen.id) {
          activeGenerator = null;
        }
        renderGeneratorNav();
        renderActiveGeneratorPanel();
      });
    }

    // --------------------------------
    // CREATE / EDIT GENERATOR BOX
    // --------------------------------
    function openNewGeneratorBox() {
      editingGeneratorId = null;
      const box = document.getElementById("generatorCreateBox");
      const msg = document.getElementById("generatorCreateMessage");
      const nameInput   = document.getElementById("genNameInput");
      const itemsInput  = document.getElementById("genItemsInput");
      const saveBtn     = document.getElementById("saveGeneratorBtn");
      const expandBtn   = document.getElementById("expandItemsBtn");
      const typeInput   = document.getElementById("genTypeInput");
      const newFolderInput = document.getElementById("genFolderNewInput");

      populateFolderSelect("General");

      nameInput.value = "";
      itemsInput.value = "";
      itemsInput.classList.remove("items-expanded");
      itemsExpanded = false;
      expandBtn.textContent = "Expand list editor";
      msg.textContent = "";
      msg.classList.remove("danger");
      saveBtn.textContent = "Save generator";
      typeInput.disabled = false;
      typeInput.value = "list";
      newFolderInput.value = "";
      newFolderInput.style.display = "none";

      box.style.display = "block";
    }

    function openEditGeneratorBox(genId) {
      const gens = loadGenerators();
      const gen = gens.find(g => g.id === genId);
      if (!gen) return;

      editingGeneratorId = genId;
      const box = document.getElementById("generatorCreateBox");
      const msg = document.getElementById("generatorCreateMessage");
      const nameInput   = document.getElementById("genNameInput");
      const itemsInput  = document.getElementById("genItemsInput");
      const saveBtn     = document.getElementById("saveGeneratorBtn");
      const expandBtn   = document.getElementById("expandItemsBtn");
      const typeInput   = document.getElementById("genTypeInput");
      const newFolderInput = document.getElementById("genFolderNewInput");

      populateFolderSelect(gen.folder || "General");

      nameInput.value   = gen.name || "";

      if (gen.type === "lexicon") {
        const arr = Array.isArray(gen.items) ? gen.items : [];
        itemsInput.value = arr.map(e => `${e.english} = ${e.valathi}`).join("\n");
      } else {
        const arr = Array.isArray(gen.items) ? gen.items : [];
        itemsInput.value = arr.join("\n");
      }

      itemsInput.classList.remove("items-expanded");
      itemsExpanded = false;
      expandBtn.textContent = "Expand list editor";

      msg.textContent = `Editing “${gen.name}”. Type: ${gen.type === "lexicon" ? "Lexicon translator" : "Random list"}.`;
      msg.classList.remove("danger");
      saveBtn.textContent = "Save changes";

      typeInput.disabled = true;
      typeInput.value = gen.type === "lexicon" ? "lexicon" : (gen.type === "list" ? "list" : "list");
      newFolderInput.value = "";
      newFolderInput.style.display = "none";

      box.style.display = "block";
    }

    function hideGeneratorCreateBox() {
      const box = document.getElementById("generatorCreateBox");
      const msg = document.getElementById("generatorCreateMessage");
      const itemsInput  = document.getElementById("genItemsInput");
      const expandBtn   = document.getElementById("expandItemsBtn");
      const newFolderInput = document.getElementById("genFolderNewInput");

      document.getElementById("genNameInput").value = "";
      itemsInput.value = "";
      msg.textContent = "";
      msg.classList.remove("danger");
      editingGeneratorId = null;

      itemsInput.classList.remove("items-expanded");
      itemsExpanded = false;
      expandBtn.textContent = "Expand list editor";
      newFolderInput.value = "";
      newFolderInput.style.display = "none";

      box.style.display = "none";
    }

    function handleSaveGenerator() {
      const folderSelect = document.getElementById("genFolderSelect");
      const folderNewInput = document.getElementById("genFolderNewInput");
      const nameInput   = document.getElementById("genNameInput");
      const itemsInput  = document.getElementById("genItemsInput");
      const msg         = document.getElementById("generatorCreateMessage");
      const typeInput   = document.getElementById("genTypeInput");

      let folder = "";
      if (folderSelect.value === "__new__") {
        folder = (folderNewInput.value || "").trim() || "General";
      } else {
        folder = folderSelect.value || "General";
      }

      const name   = (nameInput.value || "").trim();
      const raw    = itemsInput.value || "";

      if (!name) {
        msg.textContent = "Please enter a name for the generator.";
        msg.classList.add("danger");
        return;
      }

      const gens = loadGenerators();

      if (editingGeneratorId) {
        const idx = gens.findIndex(g => g.id === editingGeneratorId);
        if (idx === -1) return;

        const existingType = gens[idx].type || "list";
        let parsed;
        if (existingType === "lexicon") {
          parsed = parseLexiconText(raw);
        } else {
          parsed = parseGeneratorItems(raw);
        }

        if (!parsed.items.length) {
          msg.textContent = existingType === "lexicon"
            ? "Please provide at least one valid 'english = valathi' entry."
            : "Please provide at least one non-empty item.";
          msg.classList.add("danger");
          return;
        }

        gens[idx].folder = folder;
        gens[idx].name   = name;
        gens[idx].items  = parsed.items;
        gens[idx].type   = existingType;

        saveGenerators(gens);
        msg.classList.remove("danger");
        msg.textContent = `Updated “${name}” with ${parsed.items.length} entries. ${
          parsed.duplicates > 0 ? parsed.duplicates + " duplicates removed." : "No duplicates detected."
        }`;
        activeGenerator = { id: editingGeneratorId };
        editingGeneratorId = null;
      } else {
        const requestedType = (typeInput.value || "list");
        let parsed;
        if (requestedType === "lexicon") {
          parsed = parseLexiconText(raw);
        } else {
          parsed = parseGeneratorItems(raw);
        }

        if (!parsed.items.length) {
          msg.textContent = requestedType === "lexicon"
            ? "Please provide at least one valid 'english = valathi' entry."
            : "Please provide at least one non-empty item.";
          msg.classList.add("danger");
          return;
        }

        const id = "gen-" + Date.now() + "-" + Math.floor(Math.random() * 10000);
        gens.push({ id, folder, name, type: requestedType, items: parsed.items });
        saveGenerators(gens);
        msg.classList.remove("danger");
        msg.textContent = `Saved “${name}” in folder “${folder}” with ${parsed.items.length} entries. ${
          parsed.duplicates > 0 ? parsed.duplicates + " duplicates removed." : "No duplicates detected."
        }`;
        activeGenerator = { id };
      }

      renderGeneratorNav();
      renderActiveGeneratorPanel();

      setTimeout(() => {
        hideGeneratorCreateBox();
      }, 1200);
    }

    function toggleItemsExpand() {
      const ta = document.getElementById("genItemsInput");
      const btn = document.getElementById("expandItemsBtn");
      itemsExpanded = !itemsExpanded;
      if (itemsExpanded) {
        ta.classList.add("items-expanded");
        btn.textContent = "Collapse list editor";
      } else {
        ta.classList.remove("items-expanded");
        btn.textContent = "Expand list editor";
      }
    }

    // --------------------------------
    // NAV CLICK HANDLER
    // --------------------------------
    function handleNavClick(event) {
      const target = event.target.closest(".nav-generator");
      if (!target) return;
      const id = target.dataset.id;
      if (!id) return;

      activeGenerator = { id };
      renderGeneratorNav();
      renderActiveGeneratorPanel();
    }

    // --------------------------------
    // INIT
    // --------------------------------
    document.addEventListener("DOMContentLoaded", () => {
      renderGeneratorNav();
      renderActiveGeneratorPanel();

      document.getElementById("generatorNav").addEventListener("click", handleNavClick);
      document.getElementById("addGeneratorBtn").addEventListener("click", openNewGeneratorBox);
      document.getElementById("cancelGeneratorBtn").addEventListener("click", hideGeneratorCreateBox);
      document.getElementById("saveGeneratorBtn").addEventListener("click", handleSaveGenerator);
      document.getElementById("expandItemsBtn").addEventListener("click", toggleItemsExpand);

      const folderSelect = document.getElementById("genFolderSelect");
      if (folderSelect) {
        folderSelect.addEventListener("change", handleFolderSelectChange);
      }

      // Make sure folder dropdown has something even before first open
      populateFolderSelect("General");
    });
  </script>
</body>
</html>
